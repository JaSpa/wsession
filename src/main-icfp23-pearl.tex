\documentclass[acmsmall,screen]{acmart}
\pdfoutput=1
\usepackage{agda}
\usepackage{stmaryrd}
\usepackage{listings}

%% There is a limit of 25 pages for a full paper or Functional Pearl
%% and 12 pages for an Experience Report; in either case, the
%% bibliography and an optional clearly marked appendix will not be
%% counted against these limits. Submissions that exceed the page
%% limits or, for other reasons, do not meet the requirements for
%% formatting, will be summarily rejected. 


%% Rights management information.  This information is sent to you
%% when you complete the rights form.  These commands have SAMPLE
%% values in them; it is your responsibility as an author to replace
%% the commands and values with those provided to you when you
%% complete the rights form.
\setcopyright{acmcopyright}
\copyrightyear{2023}
\acmYear{2023}
\acmDOI{XXXXXXX.XXXXXXX}


%%
%% These commands are for a JOURNAL article.
% \acmJournal{JACM}
% \acmVolume{37}
% \acmNumber{4}
% \acmArticle{111}
% \acmMonth{8}

%%
%% Submission ID.
%% Use this when submitting an article to a sponsored event. You'll
%% receive a unique submission ID from the organizers
%% of the event, and this ID should be used as the parameter to this command.
%%\acmSubmissionID{123-A56-BU3}

%%
%% For managing citations, it is recommended to use bibliography
%% files in BibTeX format.
%%
%% You can then either use BibTeX with the ACM-Reference-Format style,
%% or BibLaTeX with the acmnumeric or acmauthoryear sytles, that include
%% support for advanced citation of software artefact from the
%% biblatex-software package, also separately available on CTAN.
%%
%% Look at the sample-*-biblatex.tex files for templates showcasing
%% the biblatex styles.
%%

%%
%% The majority of ACM publications use numbered citations and
%% references.  The command \citestyle{authoryear} switches to the
%% "author year" style.
%%
%% If you are preparing content for an event
%% sponsored by ACM SIGGRAPH, you must use the "author year" style of
%% citations and references.
%% Uncommenting
%% the next command will enable that style.
%%\citestyle{acmauthoryear}


%%
%% end of the preamble, start of the body of the document source.
\input{unicodeletters}
\input{agdamacros}

%% listings
\lstset{
  language=haskell,
  basicstyle=\ttfamily,
  morekeywords={send,recv,close,send_on_,receive,End,Int,Chan},
  captionpos=b,
  literate=
  {-o}{${\multimap}$}1
  {ex}{$\exists$}1
  {all}{$\forall$}1
  {\\x}{$\times$}1
  %{(x)}{$\otimes$}1
  {fresh}{$\lozenge$}1
  {~~}{$\approx$}1
}

\begin{document}

%%
%% The "title" command has an optional parameter,
%% allowing the author to define a "short title" to be used in page headers.
\title{Intrinsically Typed Sessions With Callbacks}
%\title{How to Embed Session Types Without Linearity}
\subtitle{Functional Pearl}

%%
%% The "author" command and its associated commands are used to define
%% the authors and their affiliations.
%% Of note is the shared affiliation of the first two authors, and the
%% "authornote" and "authornotemark" commands
%% used to denote shared contribution to the research.
\author{Peter Thiemann}
% \authornote{Both authors contributed equally to this research.}
\email{thiemann@acm.org}
\orcid{0000-0002-9000-1239}
% \author{G.K.M. Tobin}
% \authornotemark[1]
% \email{webmaster@marysville-ohio.com}
\affiliation{%
  \institution{University of Freiburg}
  % \streetaddress{P.O. Box 1212}
  % \city{Dublin}
  % \state{Ohio}
  \country{Germany}
  % \postcode{43017-6221}
}

%%
%% By default, the full list of authors will be used in the page
%% headers. Often, this list is too long, and will overlap
%% other information printed in the page headers. This command allows
%% the author to define a more concise list
%% of authors' names for this purpose.
% \renewcommand{\shortauthors}{Trovato et al.}

%%
%% The abstract is a short summary of the work to be presented in the
%% article.
\begin{abstract}
All formalizations of session types rely on linear types for soundness as
session-typed communication channels must change their type at every
operation. Embedded language implementations of session types follow
suit. They either rely on clever typing constructions to guarantee
linearity statically, or on run-time checks that approximate
linearity.

We present a new language embedded implementation of session types,
which is inspired by the inversion of control design principle. With
our approach, all application programs are intrinsically session typed and
unable to break linearity by construction. Linearity remains a proof
obligation for a tiny encapsulated library that can be discharged
once and for all when the library is built.

We demonstrate that our proposed design extends to a wide range of
features of session type systems: branching, recursion, multichannel
and higher-order session, as well as context-free sessions. The
multichannel extension provides an embedded implementation of
session types which guarantees deadlock freedom by construction.

The development reported in this paper is fully backed by
type-checked Agda code.
\end{abstract}

%%
%% The code below is generated by the tool at http://dl.acm.org/ccs.cfm.
%% Please copy and paste the code instead of the example below.
%%
% \begin{CCSXML}
% <ccs2012>
%  <concept>
%   <concept_id>10010520.10010553.10010562</concept_id>
%   <concept_desc>Computer systems organization~Embedded systems</concept_desc>
%   <concept_significance>500</concept_significance>
%  </concept>
%  <concept>
%   <concept_id>10010520.10010575.10010755</concept_id>
%   <concept_desc>Computer systems organization~Redundancy</concept_desc>
%   <concept_significance>300</concept_significance>
%  </concept>
%  <concept>
%   <concept_id>10010520.10010553.10010554</concept_id>
%   <concept_desc>Computer systems organization~Robotics</concept_desc>
%   <concept_significance>100</concept_significance>
%  </concept>
%  <concept>
%   <concept_id>10003033.10003083.10003095</concept_id>
%   <concept_desc>Networks~Network reliability</concept_desc>
%   <concept_significance>100</concept_significance>
%  </concept>
% </ccs2012>
% \end{CCSXML}

% \ccsdesc[500]{Computer systems organization~Embedded systems}
% \ccsdesc[300]{Computer systems organization~Redundancy}
% \ccsdesc{Computer systems organization~Robotics}
% \ccsdesc[100]{Networks~Network reliability}

%%
%% Keywords. The author(s) should pick words that accurately describe
%% the work being presented. Separate the keywords with commas.
\keywords{session types, domain specific languages, dependent types, Agda}

% \received{20 February 2007}
% \received[revised]{12 March 2009}
% \received[accepted]{5 June 2009}

%%
%% This command processes the author and affiliation and title
%% information and builds the first part of the formatted document.
\maketitle

\section{Introduction}
\label{sec:introduction}

\input{latex/ST-finite-nonbranching.tex}

Session types provide a type discipline for protocols
in concurrent programming systems. Each session type operator
describes the direction of communication and the type of the
payload (the transmitted value). Moreover, there are ways to specify
control structures for protocols like sequencing, branching, and
looping.

Honda and others
\cite{DBLP:conf/concur/Honda93,DBLP:conf/parle/TakeuchiHK94,DBLP:conf/esop/HondaVK98}
started the investigation of session types originally in the context
of the pi-calculus \cite{DBLP:journals/iandc/MilnerPW92a}. Later the concepts were adapted to other programming
paradigms like functional programming
\cite{DBLP:journals/tcs/VasconcelosGR06,DBLP:journals/jfp/GayV10} and
object-oriented programming
\cite{DBLP:conf/europar/RavaraV97,DBLP:journals/corr/abs-1205-5344}. 

The early works concentrated on binary session types, i.e., protocols
with two parties. Subsequently, multi-party session types were
proposed \cite{DBLP:journals/jacm/HondaYC16} that relax the
restriction to two parties. The Betty project resulted in several survey articles
and books that provide a good overview of the field
\cite{gay17:_behav_types,DBLP:journals/csur/HuttelLVCCDMPRT16,DBLP:journals/jlp/BartolettiCDDGP15,DBLP:journals/ftpl/AnconaBB0CDGGGH16}. 
For this paper, we mostly focus the discussion on the binary case, but draw some
inspiration from multi-party session types.


Session types are inextricably connected to linear types via the
Curry-Howard correspondence. This connection has been discovered and
investigated in quite some depth
\cite{DBLP:conf/concur/CairesP10,DBLP:journals/mscs/CairesPT16,DBLP:journals/jfp/Wadler14}
along with many ramifications \cite{DBLP:journals/pacmpl/BalzerP17}. 
Moreover, this connection is not just of theoretical interest, but it
has affected the implementation and (one could argue) hampered widespread
adoption. Languages constructed around session types are usually
special purpose languages that embrace linearity so that their type
checker rejects violations thereof. Examples are plenty: Links \cite{lindley17:_light_funct_session_types},
Sepi \cite{DBLP:conf/sefm/FrancoV13,DBLP:conf/sfm/Vasconcelos09}, Sill
\cite{DBLP:conf/esop/ToninhoCP13}, C0
\cite{DBLP:journals/corr/WillseyPP17}, and so on.
While these languages and their implementation have fostered research
and encouraged experimentation, they are not widely used.

To boost the use of session types, 
a lot of work has been dedicated to embedding session types in mainstream
languages, most of which do not have native support for linearity. 
There are plenty of examples for such embeddings for functional languages
like
Haskell \cite{DBLP:conf/padl/NeubauerT04,SackmanE08,
  DBLP:conf/haskell/PucellaT08} and
OCaml \cite{DBLP:journals/jfp/Padovani17,DBLP:journals/scp/ImaiYY19},
as well as object-oriented languages like
C\# \cite{DBLP:journals/corr/abs-2004-01325},
Scala \cite{DBLP:conf/ecoop/ScalasY16},
Java \cite{DBLP:conf/ecoop/HuYH08}. Most of these approaches ignore
the issue of linearity at compile time; some ignore it entirely. Some (e.g., \cite{DBLP:journals/jfp/Padovani17}) rely
on run-time checks, others rely on encodings of linearity using lenses
\cite{DBLP:journals/jip/ImaiG19} or monads \cite{DBLP:conf/haskell/PucellaT08}.
There are also extension languages with a separate checker that add
sessions \cite{DBLP:conf/coordination/NgYPHK11} or, more generally,
typestate \cite{DBLP:journals/scp/KouzapasDPG18} to an underlying Java program.
We comment on some recent implementation that rely on Rust in the
related work (Section~\ref{sec:related-work}).

Recent work on multi-party session types
\cite{DBLP:conf/cc/Miu0Y021,DBLP:journals/pacmpl/00020HNY20} suggests
an alternative approach that does not rely on linearity. It is
inspired by the design principle \emph{inversion of control} which is
familiar to programmers from GUI programming. The systems described in
those works translate a description of a multi-party session type into
a library that encapsulates the implementation of all
communication. For each communication action, the library provides an
interface where the programmer specifies a callback function for this
particular action.

To clarify this idea, we give a very simple example, continued and
extended in Section~\ref{sec:finite-nonbr-simple}, in the context of a
functional language. Unlike the cited
work, our work as well as this example rely on \emph{binary} session
types. We start with the following grammar for types $T$ and session
types $S$.
\begin{align*}
  T &::= \Aint \mid \Abool  & S &::= \Atsend{T}{S} \mid \Atrecv{T}{S} \mid \Atend
\end{align*}
The session type $\Atsend{T}{S}$ ($\Atrecv{T}{S}$) describes a channel that is ready to send (receive)
a value of payload type $T$ and the continue as $S$. The session type
$\Atend$ describes a channel that can only be closed.

\begin{description}
\item[Traditional setting] (cf.\ \cite{DBLP:journals/jfp/GayV10}) The
  traditional interface to session-typed communication consists of primitive
  operations like
  \begin{align*}
  \mathtt{send} & : \Atsend{T}{S} \otimes T \multimap S &
                                                   \mathtt{recv} &:
                                                                   \Atrecv{T}{S}
                                                                   \multimap
                                                                   (T
                                                                   \otimes
                                                                   S)
    & \mathtt{close} &: \Atend \multimap ()
  \end{align*}
  that send on a channel, receive from a channel, and close a channel.
  The crucial observation is that the type system must treat channels
  linearly to ensure protocol fidelity.

  Programs typically look like this:
\begin{lstlisting}
negp-server : ?int.!int.end -o ()
negp-server  c0 =                    -- c0 : ?int.!int.end
  let (x, c1) = recv c0 in           -- c1 :      !int.end
  let c2 = send (c1, -x) in          -- c2 :           end
  close c2
\end{lstlisting}
By linearity, the \texttt{recv} operation consumes \texttt{c0};
otherwise, another \texttt{recv} could be applied could \texttt{c0},
thus breaking the protocol.
Analogous arguments apply to \texttt{c1} and \texttt{c2}, e.g., once
the channel \texttt{c2} is closed, it cannot be closed again.
\item[Callback approach] The callback interface to session-typed
  communication proposed in this work consists of two items.
  \begin{enumerate}
  \item A datatype of commands, {\ACommand}, indexed by an application
    state $A$ and a session type. This datatype constitutes an
    intrinsically session-typed encoding of communicating functional programs.
  \item An encapsulated interpreter {\Aexecutor} to execute
    commands.\footnote{The function {\stTypeInterpretationSignature}
      maps type syntax to its interpretation as an Agda type.
      For further
      details see Section~\ref{sec:finite-nonbr-simple}.}
  \end{enumerate}
\stCommand

  The {\ACSEND} command has a callback to obtain the value to be sent
  from the application state. Similarly, the {\ACRECV} command has a
  callback to inject the received value in the application state. Both
  take a continuation command of type {\ACommand~$A$~$S$} that deals
  with the continuation session $S$. The {\ACCLOSE} command signifies
  the end of the protocol.

  A program is expressed as a value of type {\ACommand}. It looks similar to the traditional one where we choose
  {\AZ}, the integers, as the application state. The encoding relies
  strongly on the core idea of functional programming: functions
  (callbacks) as first class values.\footnote{The operator {\Adollar}
    stands for infix function application. It associates to the
    right. (The second {\Adollar} could be omitted.)}
\stNegpCommand

  The least sophisticated interpreter takes a command, a suitable
  initial application state, an untyped channel, and results in an IO
  action that produces the final application state.
\stExecutorSignature

  This interpreter is implemented once and for all in an encapsulated
  library. In a sense, it forms the trusted computing base of our
  approach, as we have the obligation to prove that it performs the
  commands on the channel according to the session type index of the
  channel. 
\end{description}

\subsection{Contributions}
\label{sec:contributions}

\begin{itemize}
\item We introduce the callback approach to binary session
  types in the context of dependently-typed functional
  programming. We deploy it as a proof-of-concept specification in the
  language Agda, but we expect our development to be transferrable to
  Haskell, either via compilation or via translation 
  \cite{DBLP:conf/haskell/CockxME0N22}.
\item Linearity of session handling is ensured by verifying linear
  handling of command execution in a small interpreter that forms the
  trusted computing base of our approach. There is no need for linear
  types in the type system of the host language, nor is there a need
  for clever type constructions to simulate linearity.
\item We demonstrate that the approach extends to most familiar
  session type constructions: branching
  (Section~\ref{sec:select-choice}), recursion
  (Section~\ref{sec:going-circles}), multichannel and
  higher-order sessions (Section~\ref{sec:handl-mult-chann}). In
  Section~\ref{sec:what-about-client} we offer a novel and significant
  improvement of the API-based treatment of recursion.
\item The extension to operate on multiple channels is significant and
  mostly orthogonal to the other features. Our approach is inspired by
  Wadler's GV calculus \cite{DBLP:journals/jfp/Wadler14} and thus
  yields deadlock-free programs by construction. 
  % It also requires several elements of multiparty session types.
\item We propose a new dynamic selection operation in the context of
  branching session types (Section~\ref{sec:select-choice}).
\item We extend the callback approach to context-free session types
  (with branching and recursion), which in turn requires a more
  sophisticated, dependently-typed encoding of commands than regular
  session types (Section~\ref{sec:context-free-session}).
% \item All our session type systems inherit the polymorphism from their
%   host language, Agda.
\item For monad lovers Section~\ref{sec:going-monadic} describes a
  version with a monadic encoding of callbacks. 
\end{itemize}

The source of this document includes a number of literate Agda
scripts which will be submitted as an anonymized supplement (to be
turned into an artifact). Every line of code that is typeset in color
has been checked by Agda. At present, the interpreters are implemented
against a small API of monadic IO operations to manipulate untyped
channels. This API can be implemented in Haskell using Agda's foreign
function interface.\footnote{An as-yet unfinished programming exercise
  that we plan to complete for artifact submission.}

As a functional pearl, this paper concentrates on the library design, it contains no
formal proofs of the proof obligations on the library interpreter
(i.e., linearity and freedom of deadlock for the multichannel
case). The discussion in Section~\ref{sec:discussion} contains some
suggestions how this task may be approached.

Working knowledge of Agda is not a hard requirement for understanding the
paper. We strive to make the code accessible to readers who are
knowledgable in Haskell by explaining features specific
to Agda as they are encountered.

\section{Finite non-branching session types}
\label{sec:finite-nonbr-simple}


Let's start straight away with the simplest instance, finite
non-branching simple session types, to convey the
gist of the approach. Subsequent sections show how to add most of the
usual features of session types.

A binary session type describes a bidirectional communication between two peers,
let's call them server and client. The session type is attached to the
type of the communication channel.\footnote{Agda supports a mixfix
  syntax where underlines in the identifier indicate the position of
  the arguments. For example,  $\Atsend{\_}{\_}$ and $\Atrecv{\_}{\_}$ are operators with two
  arguments. We declare these operators to associate to the right to
  save parentheses.}
\stFiniteType
\stFiniteSession
These Agda types correspond to the standard grammar of session types, where
$T$ is the type of payload values that can be transmitted and $S$ is the
type of sessions. 
\begin{align*}
  T &::= \Aint \mid \Abool  & S &::= \Atsend{T}{S} \mid \Atrecv{T}{S} \mid \Atend
\end{align*}
The session type $\Atsend{T}{S}$ ($\Atrecv{T}{S}$) describes a channel that is ready to send (receive)
a value of payload type $T$ and then continue as $S$. The session type
$\Atend$ describes a channel that can only be closed.

Here are two examples for session types: the types of the server for a
binary operation and a unary operation, respectively.
\stExampleBinpUnP

In GV, a widely studied functional session type theory \cite{DBLP:journals/jfp/GayV10}, there are primitives to
send and receive values and to close a channel with types like this:
\begin{align*}
  \mathtt{send} & : (\Atsend{T}{S} \otimes T) \multimap S &
                                                   \mathtt{recv} &:
                                                                   \Atrecv{T}{S}
                                                                   \multimap
                                                                   (T
                                                                   \otimes
                                                                   S)
  & \mathtt{close} &: \Atend \multimap ()
\end{align*}
The types indicate that we must treat channel values of session type
\emph{linearly}: the \texttt{send} operation \emph{consumes} a
channel, which is ready to send, paired with the payload and returns it in a state described
by $S$; the \texttt{recv} operation \emph{consumes} a channel, which
is ready to receive, and returns a pair with the received value and
the updated channel; the \texttt{close} operation \emph{consumes} the
channel and returns a unit value. Enforcing this linearity is required
for soundness.

In this work, we take a different approach inspired by callback
programming. Instead of providing \texttt{send} and \texttt{recv} 
primitives to the programmer, we ask the programmer to define the
``application logic'' by implementing a command value whose type {\ACommand} is indexed by
a session type. This definition relies on an interpretation of
types as Agda types.
\stTypeInterpretation
\stCommand
In this definition, the type parameter $A$ embodies the application state. 
Each $\ACSEND$ command takes a state transformer that extracts the value to
send from the current application state; each $\ACRECV$ command takes
a state transformer that is indexed by the received value; the $\ACCLOSE$
command terminates the session. In fact, we could provide the
application logic by actions in a state monad over the application
state $A$. We defer the shift to a monadic interface to Section~\ref{sec:going-monadic},
when we have the full picture.

Continuing our example, we define commands that implement a server
for the protocols {\Aunaryp} and {\Abinaryp} with the operation instantiated to
negation and addition, respectively.
\stNegpCommand
\stAddpCommand  
 We use explicit lambda abstraction instead of fancy abbreviations and library combinators
for clarity; the variable $a$ stands for the application state and $x$ and $y$ for
the respective values received from the channel. For connoisseurs of pointfree definitions, we give a
more concise version of the addition command using functions from the
standard library:
\stAddpCommandAlternative

To execute commands, we write an
interpreter that relies on primitive operations provided
in the $\AIO$ monad. The point of our approach is that this
interpreter is the single definition where we are obliged to prove
that it handles channels in a linear fashion. 
\stPostulates
This API should be self-explanatory.\footnote{The type $\top$ is like
  Haskell's unit type with single element {\Att}.} It declares an abstract type of
untyped, raw channels with operations to accept a connection, close a channel, as
well as send and receive a value over the channel. It glosses over issues like
serialization, which can be addressed using type class constraints like
{\ASerialize~$A$} (in Haskell) on {\AprimSend} and {\AprimRecv}.
% Our shared memory implementation relies on unsafe casts.

The interpreter itself is defined by induction on the type
{\ACommand}. The actual computation takes place in the {\AIO} monad and is expressed using the {\Ado} notation, both
familiar from Haskell. 
\stExecutorSignature\vspace{-1.5\baselineskip}
\stExecutor
To actually run a server, it remains to provide a wrapper that accepts
a connection and invokes the interpreter.
\stAcceptor
Examining the interpreter, we finally see the full monadic
structure. We need a stack of monad transformers starting with a state
monad for the application state on top of a reader monad providing the
channel on top of the IO monad.

Our proof obligation for the interpreter boils down to verifying that
the interpretation of each command executes the single communication
action designated by the corresponding session type operator. The
correct sequencing according to the session type is imposed by the
sequencing constraint underlying the {\AIO} monad. Indeed, this
observation was the reason to employ monads for APIs to state-based
operations in pure functional languages \cite{DBLP:conf/popl/JonesW93}.

\section{Selection and choice}
\label{sec:select-choice}

Adding branching to our development is straightforward. The standard 
theory of session types allows branching on a finite set of labels using this syntax:
\begin{align*}
  S & ::= \dots \mid \oplus\{ \ell : S_\ell \mid \ell \in L \} \mid
      \&\{\ell: S_\ell \mid \ell \in L\}
\end{align*}
Here $L$ is a finite, non-empty set of labels, which can be chosen differently at
every use of the type operator. 
The type constructor $\oplus$ corresponds to an \emph{internal choice} of the
program.  The \texttt{select} primitive sends one of the labels, say $\ell \in L$, available in the
type and continues according to $S_\ell$:
\begin{align*}
  \mathtt{select}\ \ell &: \oplus\{ \ell : S_\ell \mid \ell \in L \}
                          \multimap S_\ell
\end{align*}
The type constructor $\&$ corresponds to an \emph{external choice}. The
primitive \texttt{branch} receives one of the labels 
mentioned in the type and chooses a continuation according to the
label. In the presence of sum types and linearity, the primitive can be typed as
follows \cite{DBLP:journals/toplas/Padovani19}.
\begin{align*}
  \mathtt{branch} &: \&\{\ell: S_\ell \mid \ell \in L\} \multimap +\{\ell: S_\ell \mid \ell \in L\}
\end{align*}
Our modeling in Agda extends the definitions of
{\ASession}, {\ACommand}, and {\Aexecutor} from
Section~\ref{sec:finite-nonbr-simple}. A label set of size $k$ is
modeled by the type $\AFin~k = \{ 0, \dots, k-1\}$ and the alternative continuation sessions by
functions from labels to {\ASession} (isomorphic to vectors of sessions, cf.\  Section~\ref{sec:select-choice-with}).
\stBranchingType
\stBranchingCommand
The commands for {\ACSELECT} and {\ACCHOICE} only differ in the
placement of the parentheses: {\ACSELECT} takes a label and a command
corresponding to this label, whereas {\ACCHOICE} takes a function that
maps a label to its command. Neither command requires the application
state: the selection is static and does not depend on the current
state; once the external choice has been taken, the chosen command can
reflect that choice in the application state.
\stExecutorSignature\vspace{-1.5\baselineskip}
\stBranchingExecutor

Extending our running example, we define the type of an arithmetic server,
which gives a choice between a binary operation and a unary one. 
This definition uses a smart constructor {\Aamp} for the external choice that
takes a vector of session types and transforms it into the
corresponding function.\footnote{This transformation relies on the
  isomorphism between vectors of size $k$ and non-dependent functions with domain {\AFin~$k$}.}
\stExampleArithP
The command for the server extends in the obvious way. The vector
trick does not work for the {\ACommand} constructors {\ACSELECT} and
{\ACCHOICE} because their arguments are dependent functions that
generally return different types for different arguments.
\stArithpCommand

Finally, we observe that the proposed interface enables a more dynamic
selection operator than in standard session types. While the standard
select operator is indexed by a label that is fixed at compile time,
we can supply a dynamic selector command where the label is computed
by a callback \AgdaFunction{getl} at run time:
\stDynamicBranchingCommand
Extending {\Aexecutor} to this command is straightforward.
There is still room for improvement in the type of this command. We
come back to this issue in Section~\ref{sec:context-free-session}.

\section{Going in circles}
\label{sec:going-circles}
\input{latex/ST-recursive.tex}

Recursive types are a common feature of session types. They are required
to model protocols for servers that perform the same functionality
over and over again. Our running example will be a server that allows
a client to repeatedly perform a unary operation until the client
quits.

The pen-and-paper syntax of recursive types relies on type variables
and a $\mu$ operator like so:\footnote{We gloss over the issue of
  guardedness (or contractiveness) for recursive types to avoid further complexity in the
  types.}
\begin{align*}
  S &::= \Atsend{T}{S} \mid \Atrecv{T}{S} \mid \Atend \mid
      \Amu~X. S
      \mid X
      \mid \dots
\end{align*}
The intended semantics of the $\Amu$ operator is that $\Amu~X.S$ is
equivalent to $S[X \mapsto \Amu~X.S]$, the unfolding, where we
substitute the recursive type itself for the variable $X$ in its body.

For the Agda formalization we choose the standard de Bruijn encoding
of bound variables. The parameter $n$ of
the {\ASession} type denotes the number of type variables in
scope. The {\Amu} operator opens a new scope and {\Aback~$i$}
references the $i$th variable, the innermost binding being $0$.
\rstSession

Further extending our running example, we redefine the protocol {\Aunaryp} as a function
that takes the rest of the protocol and wraps it into a recursive
type. The session type {\Amanyunaryp} is a recursive type that either
runs a unary function and recurses or just ends the protocol. We
define {\Aamp} as a smart constructor as in Section~\ref{sec:select-choice}.
\rstExampleManyUnaryp

\subsection{Commands}
\label{sec:commands}



The {\ACommand} type obtains a new
parameter $n$ to match the parameter of the session type used as an
index. We only show the two new cases.
\rstCommand

With this type we are ready to implement a
service that repeatedly adds numbers as they are received and sends the partial
sum as a response each time.
\rstSumupCommand

\subsection{Interpretation}
\label{sec:interpretaion}


Executing a command with recursion requires a new component in the
executor. Whenever execution enters a {\AMU} command, this component
saves the entire loop on a stack. When we encounter a {\ACONTINUE~$i$}
command, we grab the corresponding loop from the stack and
continue with it. There are a few complications in setting up this new
component that we call {\ACommandStore}.

\begin{figure}[tp]
  \begin{align*}
    &
      \begin{array}[t]{|ll|}
        0 &\mapsto \ASession~0
      \end{array}
    &&
      \begin{array}[t]{|ll|}
        0 &\mapsto \ASession~1 \\
        1 &\mapsto \ASession~0
      \end{array}
          &&
             \dots
    &&
       \begin{array}[t]{|ll|}
         0 & \mapsto \ASession~n \\
         1 & \mapsto \ASession~(n-1) \\
           & \vdots \\
         n-1 & \mapsto \ASession~0
       \end{array}
  \end{align*}
  \caption{The session type indices in {\ACommandStore} after 1, 2, and $n$ loop entries}
  \label{fig:commandstore}
\end{figure}
Its type requires some thought.  The top-level type is a
{\ASession~0}. When we enter the first loop, its type is {\ASession~0}. Hence, the {\ACommandStore} contains
one entry (left column in Figure~\ref{fig:commandstore}).
Entering the next loop pushes a loop of type {\ASession~1}
(middle column). After entering the $n$-th loop, we obtain the
picture on the right of Figure~\ref{fig:commandstore}. Here is a
suitable type definition.
\rstCommandStore

For some $(i : \AFin~(\Asuc~ n))$, the function
$\AgdaFunction{opposite}~i$ returns $n-i$ (as an element of the same
type) and the function {\AtoN} injects an element of the finite number
type into the natural numbers (it is an identity function up to the type). The tricky part is implemented in the
typed push and pop operations on that structure.
\rstPops

The \AgdaFunction{push} function takes a {\ACommandStore} and a
suitable {\ACommand} and returns the store extended by this command
(at position {\Azero}). 
The \AgdaFunction{pop1} function pops the first entry off the
{\ACommandStore}. It gets used in defining the inductive step of the
function \AgdaFunction{pop}, which pops any (legal) number $i$ of entries
from the stack. The definitions are simple but omitted from the text
as they require invoking some technical lemmas about injections (i.e.,
identity functions) from $\AFin~n$ to $\AFin~(\Asuc~n)$.

\rstExecutorSignature\vspace{-1.5\baselineskip}
\rstExecutor

The execution of {\AMU} just pushes the loop onto the
{\ACommandStore} and executes the body.
The case for {\ACONTINUE~$i$} jumps to the selected loop and pops
all intervening continuations from the store. It also reveals another complication. The recursive
call to {\Aexecutor} happens on a command drawn from the {\ACommandStore}. This
command is unrelated to the current command, which upsets Agda's
termination checker. To console it we introduce a \AgdaFunction{Gas}
argument, which we decrement at each {\ACONTINUE}.

The question is, what to do if we run out of gas?
There are at least three possibilities.
\begin{enumerate}
\item We regard the current formalization as a proof of concept and
  refer the reader to a ``real'' implementation in Haskell, where the
  \AgdaFunction{Gas} argument is not required. We see no
  problem in creating such an implementation, but it would be more
  involved as dependent types are not yet fully integrated in Haskell.
\item We turn the bug into a feature and require that every
  {\ACONTINUE} communicates with the other end of the channel to
  exchange their respective gas levels and quit the loop if one end
  runs out of gas. This choice implies that we would have to a
  continuation argument to  {\ACONTINUE} that acts like a
  finally-clause for exception and finishes the protocol in an orderly
  way.
\item We can modify {\Aexecutor} so that it always takes a single step
  and returns either a continuation and an intermediate state or a
  final result of type $A$. This modification is straightforward in 
  the setting with loops as a value \AgdaFunction{cms} of type {\ACommandStore~$(\Asuc~n)$~$A$}
  can serve as a continuation. To restart a continuation, we simply invoke
  {\Aexecutor} on \AgdaFunction{cms}~\Azero. For concreteness, we show
  the continuation type and an implementation of the restart function.
  \rstAlternativeExecutorRestart
  With this approach, the management of {\Arestart}  has to be
  included in the trusted computing base as it also has to guarantee linear treatment of
  the channel.
\end{enumerate}
The current formalization leaves that question open and just breaks
the protocol. Our preferred solution is a Haskell implementation,
which omits the gas and thus sticks to the protocol.

\subsection{What about the client?}
\label{sec:what-about-client}

The commands we presented so far for recursive sessions are fine for
servers that repeatedly perform the same action. However, a client
might want to perform different actions on each iteration. While such
a behavior may be encoded in the application state, it would not be an
enjoyable experience for the programmer.

Hence, we propose an {\AUNROLL} command that
enables the specification of a command for one loop iteration at a time.
\rstCommandUNROLL
It specifies one command for the session type's loop body and a
continuation command for the whole type to cover subsequent
iterations. 
Executing this command means to execute its body and push its
continuation on the stack.
\rstExecutorUNROLL
As an example, we write a client for the {\Amanyunaryp} protocol that
iterates the protocol two times before it terminates. In each round,
it sends an integer and ignores the response.
\rstClientExample

\section{Going monadic}
\label{sec:going-monadic}
\input{latex/ST-monadic.tex}

We already remarked on the monadic structure apparent in the
callbacks and in the implementation of the {\Aexecutor}
function. Indeed, moving on to a monadic interface might make our session
programs more concise.

We start with a slightly refactored type of commands. More precisely,
we introduce a new {\ACSKIP} command that only performs a state 
transformation via its single callback.
Second, we restate the types of the callbacks for {\ACSEND} and
{\ACRECV} in terms of the state monad.

\mstCommand

Here are the specifics of the types of the callbacks. Each callback
runs in a state monad that handles the application state $A$ on top of
another monad $M$. This construction is expressed in terms of the
monad transformer {\AStateT} applied to the application state
$A$ and the underlying monad $M$. The type of the callback does not give away more
than that.

But wait, using the Agda standard library, we have to state that $M$
has a type that fits a monad and that it implements the
interface {\ARawMonad} (a record that contains the basic monadic
operations).
Fortunately, we can abstract from these issues and adopt a
Haskell-inspired syntax with a straightforward
Agda definition.\footnote{Agda's \AgdaKeyword{syntax} command defines
  a macro that enables abstraction over binders. The newly introduced
  syntax, the definiendum, is \emph{on the right} of the equals
  sign. Putting the record {\ARawMonad~$M$} in double braces enables overloading of the
  monadic operators \cite{DBLP:conf/icfp/DevrieseP11}.}
\mstMonadic

Our running examples become (even more?) concise:
\mstExampleServers
Here, {\Aput}, {\Amodify}, and {\Aget} are monadic functions defined
in the state monad transformer. Their full types are fairly
unreadable, but intuitively we can treat them like this:
\begin{align*}
  \Aput &: A \to ST~A~\top
  & \Amodify &: (A \to A)\to ST~A~A
  & \Aget &: ST~A~A
\end{align*}
{\Aput} overwrites the state with its argument; {\Amodify~$h$} applies 
function $h$ to the state and returns the new state; and {$\Aget = \Amodify~\Aid$} returns the current state.

While we are at it, we also define the {\Aexecutor} function in
monadic style. At this point, the full type of the execution monad
emerges. We already encountered the state transformer on top for
handling the application state. Below we find a reader monad (again
implemented using a monad transformer) that handles access to the
channel. At the bottom, we have the IO monad as before.
\mstExecutor

The most remarkable aspect of this implementation is how unremarkable
it is. However, bear in mind that monads have been used for a long
time to contain linear resources, most notably with the inception of
monadic IO \cite{DBLP:conf/popl/JonesW93}. That is, our proof
obligation of linear handling for the channel becomes even simpler in
this monadic setting.

We conclude this section with the definition of the monadic
acceptor. It essentially invokes the runners of the reader and state
monads and executes the underlying IO action.
\mstAcceptor

\section{Context-free session types}
\label{sec:context-free-session}
\input{latex/ST-indexed-contextfree.tex}

Context-free session types
\cite{DBLP:journals/iandc/AlmeidaMTV22,DBLP:journals/toplas/Padovani19,DBLP:conf/icfp/ThiemannV16}
have been conceived to liberate session types from the restriction to
tail recursion. Alleviating this restriction makes session-typed
programming more compositional and enables low-level programming tasks
like the serialization of tree structures.

The basic idea \cite{DBLP:conf/icfp/ThiemannV16} is to reorganize the
type language of session types as follows.
\begin{align*}
  S &::= \Atcfsend{T} \mid \Atcfrecv{T} \mid \Atcfcomp{S}{S} \mid \Atcfskip
\end{align*}
Now $\Atcfsend{T}$ ($\Atcfrecv{T}$) describes just the act of sending
(receiving) a value of type $T$. To combine two session types, we have
to use sequential composition $\Atcfcomp{S}{S}$ with unit
$\Atcfskip$. The branching types and recursion are as before, so we do
not repeat them here.

The Agda encoding of this structure combines straightforwardly with
the accumulated work of the previous sections.
\cstSession

The revised command structure has a few catches that require
explanation.
\cstCmd

The {\ACommand} datatype now carries four type-related parameters on
top of the session type. A command of type {$\ACommand~A~B~V~W~S$} is
firstly an action that takes an input of type $A$, yields an output of
type $B$, and executes a session according to $S$. The additional
parameters, $V$ and $W$, are vectors of types that control the typing
of the currently pending loops, which are explained with the commands
{\AMU} and {\ACONTINUE}. For now, we can think of them as stack of
the input and output types of those pending loops.

The {\ACSKIP} command is associated with a {\Atcfskip} in the session
type. It comes with a function that transforms $A$s into $B$s.
% This connection is sometimes needed, but most often it is
% undesired. To eliminate superfluous {\Atcfskip}s in the type, we
% provide a smart composition constructor that simplifies compositions
% with {\Atcfskip}.

The {\ACSEND} and {\ACRECV} commands no longer take a command parameter
to process the continuation session. This functionality is now
provided once and for all by the composition operator.

The command {\ACSELECT} prescribes dynamic selection. It takes a
callback that maps a value of input type $A$ to a dependent pair of a
label $i$ and a value of type $F~i$.\footnote{The negative occurrence
  of the $F$ parameter is not permitted in the constructor of a
  {\ASet} datatype. Its presence forces the command type one level up
  into {\ASetOne}.} The continuation takes advantage of this
fine-grained type information by associating the label $i$ with the
input type $F~i$ as produced by the callback.

The {\ACCHOICE} command is as before up to the additional type parameters.

The composition operator for two commands has three additional
callback arguments, which we call {\Asplit}, {\Across}, and
{\Ajoin}. The first callback {\Asplit} splits the input type into one part that gets
consumed by the first command and another that bypasses it.
The second callback {\Across} joins the output type and the bypass into the
input type for the second command.
The third callback {\Ajoin} combines the outputs of the two commands.
% Quite
% often, with tail-recursive session types, we simply ignore the outcome
% of the first command and pass on the second.

In the context-free case, the behavior of the {\AMU} command is more
general than the simple tail-recursive iteration in
Section~\ref{sec:going-circles}. It takes a loop body that transforms
$A$s into $B$s with these same types pushed on the stacks.

The {$\ACONTINUE~i$} command invokes the $i$th pending loop. To do so,
the current type must match the typing of the loop, which we find by
lookup up the input and output type on the stacks at position $i$.

\subsection{Examples}
\label{sec:examples}



Before we delve into the interpreter, let's take stock what we
achieved by reviewing our old examples as well as a new one that
demonstrates the additional expressivity of context-free sessions.
\cstBinaryp

Compare these types with the corresponding ones from
Section~\ref{sec:going-circles}, where the protocol fragments are
metafunctions that take a continuation session as a parameter. No such
parameterization is needed with context-free session types. They are
intrinsically compositional and modular.

The final example {\Amanyunaryp} contains a tail recursive part. The
second component of the choice must make use of the {\Atcfskip} type,
because the arm of a choice cannot be empty.

Let's consider servers that implement those protocols.
\cstCmdExamples

The code of the servers does not look that different from
before. However, unlike before, each server is now reusable as part of
the implementation of a larger protocol. One indication is the use of
the parameters $V$ and $W$ in the types, another is the lack of the
{\ACCLOSE} constructor which prescribes closing the connection.

As these protocols are still tail-recursive, their implementation uses
a binary composition operator for commands that is tailored for this
use case. The split function feeds everything to the first command; the
cross operation ignores the bypassed value, passing only the output of
the first command to the second; and the join operation passes only
the output of the second command.
\cstTailComposition


To further pinpoint the difference between context-free sessions and
regular session we finally present a protocol that
exploits the power of context-free session types by going beyond tail
recursion: servers that receive and send binary trees. 
\cstTreep

The session types {\Aleafp} and {\Abranchp} encode receiving a leaf and
a branch of the binary tree type {\AIntTree}. The session type
{\Atreep} provides the enclosing recursion and choice between the leaf
and branch protocols. As {\Abranchp} contains two recursive calls,
the protocol {\Atreep} is no longer tail recursive.
\cstRecvTree
The receiver for the leaf (choice {\Azero}) wraps the received value in the {\ACLeaf}
constructor and returns it.
The receiver for the branch (choice {\Asuc~\Azero}) obtains the left and right subtrees by
recursive calls {\ACONTINUE~\Azero} and combines the outcomes using
the {\ACBranch} constructor. The {\Asplit} and {\Across} callbacks
just manipulate values of unit type.

The sender of a tree makes full use of the callbacks for command
composition. 
\cstSendTree
The function {\AsplitTree} implements essentially (one half of) the
isomorphism that unfolds the recursion in type {\AIntTree};
function {\AIntTreeF} helps construct its type. It is straightforward
to construct the sender of a tree using these helpers. Using
{\AsplitTree} as the callback for {\ACSELECT}, we find that the
{\Azero} branch is invoked with an integer and the {\Asuc~\Azero}
branch is invoked with a pair of the two subtrees. The {\Asplit}
callback is just the identity, so that the left subtree is passed to
the first recursive call and the right one to the second.

\subsection{Interpretation}
\label{sec:interpretation}


We show the full {\Aexecutor} function and finish with a rationale why
the callback interface in this section is not monadic.
\cstExec

The implementation of {\ACSKIP} just executes the action.
Sending  {\ACSEND}, receiving  {\ACRECV}, and choice {\ACCHOICE} are as usual.
The dynamic selection is improved with respect to
Section~\ref{sec:select-choice}. Previously, there was no connection
between the selected label and the executed continuation, so that a
bug in the interpreter might introduce a mismatch. In the present
interpreter, no such mismatch is possible because it would be a type
error to invoke any other continuation than $\Acont~i$ with $ai$.

Composition first splits the input using the {\Asplit} callback. It performs the left command, obtains its final state in
$b_1$, combines it with the bypass value $a'$ using {\Across}, and
then performs the right command. It obtains its final state in
$b_2$ and returns $\Ajoin~a_1~a_2$.
The implementations for {\AMU} and {\ACONTINUE} are as before in
Section~\ref{sec:going-circles}. The difference is that the
{\ACONTINUE} operation may now appear in the context of a composition
which provides a nontrivial continuation. In
Section~\ref{sec:going-circles}, the function {\Aexecutor} is tail
recursive, but here it is not!

Now we turn to the question of the monadic callback interface. 
Examination of the code reveals that the state monad is no longer the most appropriate model of a
callback. On first sight, the type $A \to 
M~B$ is the same as $\AReaderT~A~M~B $. However, the case 
for composition shows that a reader does not fit because
the type $A$ of the reader's source changes between recursive calls to
the interpreter. Moreover, the callbacks for composition do not fit
the pattern of the reader monad at all.
Thus, we refrain from the monadic interface.


\section{Handling multiple channels}
\label{sec:handl-mult-chann}
\input{latex/ST-multichannel.tex}

We have to amend some final elements to fully encompass traditional binary
session types: a thread can open and manipulate many channels at a
time and channels can be delegated. So far, our interfaces were
restricted to single channels and to transmitting pure data (i.e., no channels). We
now turn to lifting these restrictions.

To concentrate on the new issues, 
we start out by slightly rephrasing session types as we
know them from Section~\ref{sec:select-choice}. In particular, we
restrict to binary branching and leave the extension
to finitary branching as well as the addition of recursion as an
exercise to the reader. Generally, these types describe 
the communication on a single channel, as before. There are two novel
aspects: we factorize the specification of the direction of
communication and we add a special type for channel delegation, i.e.,
sending or receiving a channel.

\multiSession

An actual multichannel session type describes the interleaved
communication on all channels at once. It comes with features and
restrictions very similar to multiparty session types \cite{DBLP:journals/jacm/HondaYC16}.

\multiMSesson

A multichannel session type {\AMSession~n}, ranged over by $M$, is indexed by the number $n$ of
channels that it governs. Multichannel session types are loosely based on Wadler's GV
calculus \cite{DBLP:journals/jfp/Wadler14}. In particular, the
connection topology of multichannel programs is restricted in the same
way as in Wadler's GV, with the pleasing
consequence that they are guaranteed to be free of deadlocks.

The names of the channels are represented by
de Bruijn indices. Unlike in other embedded implementations, a
multichannel type covers the full choreography of a communicating
application: connecting (forking) to a new process is combined with channel creation, branching and transmitting values as usual, closing a
channel, delegation, and terminating the application after all
protocols are finished and their respective channels closed.

Each multichannel type, except {\ACconnect} and {\ACterminate}, takes a parameter
$c$ that identifies the channel on which the command operates. 
The type to transmit a value (\ACtransmit) is as before, save the
direction and channel parameters. Branching (\ACbranch) is as before
except the extra function {\ACausality}: it ensures that a branch is
reasonable by enforcing that the session on every channel except $c$
is not affected by the branch. This restriction is called
``Causality'' in the context of multiparty session types. It is needed
because only the party on other end of channel $c$ knows about the
branching, but the others do not.

The {\ACclose} type has a continuation parameter because a channel
can be closed in the middle of a choreography without terminating the
multichannel protocol. Once all channels are closed, the choreography
can be concluded using the type {\ACterminate}.

The type {\ACconnect} indicates creation of a new thread which runs protocol $M_1$
whereas the current thread continues with $M_2$. The currently open
channels are distributed among the threads according to the {\ASplit}
parameter.
Communication with the new thread is established by 
creating a new channel, which is mapped to address {\Azero} in both
threads. Moreover, the {\ACheckDual} predicate makes sure that the
session types of the two ends of this channel are dual to one
another.\footnote{We elide details about the {\ASplit} type as well as
  duality from the paper for space reasons. See the supplement.}

The delegation types deal with sending (receiving) a channel over
another channel. Their types are sufficiently different so as not to
factor out the direction. To send a channel $j$ using {\ACdelegateOUT}, we need to know that
the transmitted channel is not the same channel we are sending on, its simple session type,
and that the continuation command has one fewer channel.
To receive a channel using {\ACdelegateIN} we just map it to address
{\Azero} in the continuation session.

The function {\Aproject} is similar to the projection from global
types to local types in multiparty session types. We make use of
auxiliary functions that manipulate de Bruijn indices:
{\AlocateSplit~sp-c~c} determines the target thread of channel $c$ and
its local index; {\Aadjust} changes the index to account for a channel
that is removed from choreography. {\ACausality} and {\ACheckDual} are
implemented using the obvious formulas.
\multiProjection

Given the preceding discussion as well as the discussion in previous
sections, the types of commands follow directly.

\multiCmd

Likewise, the interpreter {\Aexec} is an easy exercise.

\multiExec


\section{Discussion}
\label{sec:discussion}

% \subsection{To monad or not to monad}
% \label{sec:monad-or-not}

% We proposed a monadic callback interface in Section~\ref{sec:going-monadic},
% but reverted to a non-monadic one in subsequent sections. While the
% monadic implementation of the interpreter is worthwhile and improves
% conciseness and readability, it is not clear whether there is a
% significant difference for the callbacks themselves.
% To be fair, the choice to revert to the non-monadic interface in
% Section~\ref{sec:context-free-session} was partially forced on us by
% some restrictions on level polymorphism in the implementation of indexed functors in
% the standard library.

\subsection{Selection and choice with vectors}
\label{sec:select-choice-with}

The reader may wonder why we do not define the constructors for
selection and choice using vectors of length $n$, rather than
functions from $\AFin~n \to \ASession$ (which is isomorphic). Using a function extends
directly to the definition of the {\ACommand} type where the {\ASession} index of the
continuation command depends on the function argument $i : \AFin~n$.
We would have to define a special dependent vector type to achieve similar
expressivity. 

\subsection{Alternative representations}
\label{sec:code-generation}

Instead of interpreting a command value, we could compile it to a
custom library, following the lead of the related work
\cite{DBLP:journals/pacmpl/00020HNY20,DBLP:conf/cc/Miu0Y021}.
Such a compiler can be obtained specializing the command interpreter
with respect to single commands.

The resulting \emph{denotational implementation} corresponds to a library implementation that exposes
the commands, which are reified in a datatype in our approach, as
functions. This approach has been pioneered by Reynolds \cite{Reynolds1994} and
subsequently applied, e.g., in the context of partial evaluation and
program analysis
\cite{DBLP:journals/jfp/Thiemann99,DBLP:journals/jfp/CaretteKS09}.

Here is an excerpt of such an implementation derived from the
interpreter in Section~\ref{sec:finite-nonbr-simple}.
\stCombinators
The interpreters from other sections can be rephrased analogously
without sacrificing the advantages our approach. However, for program
development the command-based approach is more attractive because the
Agda interactive programming support features autocompletion for commands, but not
for combinators.

\subsection{Multiparty session types}
\label{sec:mult-sess-types}

We see no issues in extending the approach presented in this work to
protocols with more than two participants. We refrained from doing so
in this work to avoid the extra
complication. Section~\ref{sec:handl-mult-chann} already gives some
insight into the requirements for a full multiparty version.

\subsection{Verification}
\label{sec:verification}

A fly in the ointment of our approach is the proof obligation that
the interpreter does not break linearity. As the interpreters are very
simple, it is tempting to rely on manual inspection.

To obtain a formal and possible mechanized proof, we envision a
semantics in terms of a free monad
\cite{DBLP:journals/jfp/Swierstra08,DBLP:conf/haskell/KiselyovI15}
with uninterpreted occurrences of 
the operations of our primitive channel IO API. The actual proof might be
conducted using interaction trees
\cite{DBLP:journals/pacmpl/XiaZHHMPZ20}, a mechanized framework for
representing about recursive and impure programs and  reasoning about them.

\section{Related work}
\label{sec:related-work}

In this section, we review how different library implementations of
session types deal with linearity. Specifically, we do not consider
dedicated language implementations like
SILL \cite{DBLP:conf/esop/ToninhoCP13},
SEPI \cite{DBLP:conf/sefm/FrancoV13},
FreeST \cite{DBLP:journals/iandc/AlmeidaMTV22},
or Links \cite{lindley17:_light_funct_session_types}. These
implementations come with dedicated type checker that properly treat
linearity at compile time.

There are libraries with fully dynamic enforcement of a session type
discipline
\cite{DBLP:conf/rv/HuNYDH13,DBLP:journals/pacmpl/MelgrattiP17}. They
suffer from run-time overhead as they have to check every
communication operation and they lack guarantees as they terminate the
protocol when an error is detected at some peer. 

Several libraries perform
linearity checks at run time. While a check for at most one (affine)
use of a resource can be performed with a single bit
\cite{DBLP:conf/esop/TovP10},  checks for linearity are more
expensive, but still deemed lightweight
\cite{DBLP:conf/fase/HuY16}.

Several libraries statically enforce linearity by encoding it
using parameterized monads
\cite{SackmanE08,DBLP:conf/haskell/PucellaT08},  polymorphism
\cite{DBLP:journals/scp/ImaiYY19}, or higher-order 
abstract syntax \cite{DBLP:conf/haskell/LindleyM16}. While these
encodings cleverly exploit the facilities of the host language and
support type inference, they
are nontrivial to explain and yield types that are not easy on the
programmer. No such cleverness is needed in our approach; types are
human-readable and the interactive Agda system helps with constructing
types and programs, but session types are not inferred.

None of the existing embeddings offers a feature like our dynamic
selection. However, dynamic selection can be viewed as a special case
of label-dependent session types
\cite{DBLP:journals/pacmpl/ThiemannV20}, so that our  approach
implements part of that theory, too.

While the dynamic and object-oriented libraries support session
subtyping, our approach currently does not support subtyping. 


The most closely related work is by Miu, Ferreira, Yoshida, and Zhou
\cite{DBLP:conf/cc/Miu0Y021}. They develop an
implementation of multiparty session types in TypeScript by generation
of custom libraries from a protocol specification. Their
implementation guarantees freedom from
communication errors, including deadlocks, communication
mismatches, channel usage violation or cancellation errors. They
generate TypeScript APIs in callback style, where the finite state
machine underlying the communication endpoints is reified in terms of
interfaces. Sending and receiving are both encoded via callbacks 
into the library or into the user program, as appropriate. The
generated APIs encapsulate all primitive communication operations.



\subsection{Haskell}
\label{sec:hask-impl}

The earliest Haskell implementation by Neubauer \cite{DBLP:conf/padl/NeubauerT04}
emphasizes the modeling of the type of a single session using phantom
types. Duality is implemented using type classes with functional
dependencies. Linearity is not considered.

Sackman \cite{SackmanE08} and Tov \cite{DBLP:conf/popl/TovP11} model
multiple channels using a parameterized monad that is indexed by a mapping
from channel names to their current session types. The mapping changes
with each operation to keep track of the current state of all
channels. The monadic interface guarantees linearity.

This approach leaves more freedom to the programmer than our proposal
in Section~\ref{sec:handl-mult-chann}. While individual channel types
are independent in their approach, our multi-channel session types
impose a choreography on all connections, which is closer in spirit to
multiparty session types. 

Lindley and Morris \cite{DBLP:conf/haskell/LindleyM16} extend a HOAS
encoding of linear lambda calculus with monads and session primitives
in the style of GV \cite{DBLP:journals/jfp/GayV10}. They call their approach
``parameterized tagless'' \cite{DBLP:journals/jfp/CaretteKS09}, which means that they encode the syntax of
lambda calculus and the session primitives in term of parameterized
functions in a type class with implementations provided subsequently.

Orchard and Yoshida \cite{DBLP:conf/popl/OrchardY16} discuss
connections between session types and effect systems. They present an
implementation of session types in Haskell via an effect system
encoding based on graded monads. Here the ``grading'' keeps track of
the currently active channels and their session types whereas the
monadic structure provides proper sequencing.


\subsection{OCaml}
\label{sec:ocaml}

The implementation of FuSe \cite{DBLP:journals/jfp/Padovani17}
consists of a typed layer on top of untyped channels (just like our
approach).  It provides an API inspired by GV, supports
type inference, and checks linearity at run time. The approach is
extensible to context-free session types
\cite{DBLP:journals/toplas/Padovani19} at the expense of some user
annotations (while keeping type inference).

Session OCaml \cite{DBLP:journals/scp/ImaiYY19} enforces linearity by
parametric polymorphism based on a technique by
Garrigue\footnote{See \url{https://github.com/garrigue/safeio}.} with significant
extensions to deal with session types.
It can handle a fixed number of channels at the same time with
globally defined channel names (slot names). The technique hinges on
the polymorphic types of the global slot names.
Session types are inferred from programs that can be written in a notation
similar to FuSe and GV.


\subsection{Java}
\label{sec:java}

The early interface proposed in ``Session-based distributed programming in Java''
\cite{DBLP:conf/ecoop/HuYH08} relied on special syntax for session
communication and a preprocessor to limit aliasing.
Mungo \cite{DBLP:journals/scp/KouzapasDPG18} and Bica
\cite{DBLP:journals/corr/abs-1205-5344} use similar ideas to implement
typestate and sessions.

Hu and Yoshida \cite{DBLP:conf/fase/HuY16} pioneered code generating
approaches for implementing multiparty session types. They generate protocol-specific
endpoint APIs from multiparty session  
types for Java, but claim generality of their approach for mainstream
languages. They start from the observation that the behavior of an
endpoint of a communication can be represented by a finite state
machine. Each of these states is reified as a state channel type with
methods that imply communication operations corresponding to state
transitions. As Java places no restrictions on object uses, they
deploy ``very light run-time checks in the 
generated API that enforce a linear usage discipline on instances of
the channel types.'' Their abstract I/O state interfaces are closest
to the facilities that we provide.

While their approach reifies the different possible states of a
communication endpoint, these states are implicit in our
approach. Moreover, while an API based on finite state machines is
entirely appropriate for servers, we can provide additional
flexibility for implementing clients of recursive protocols though
commands like {\AUNROLL} described in
Section~\ref{sec:what-about-client}.

Scalas work for Scala \cite{DBLP:conf/ecoop/ScalasY16} follows similar
ideas with run-time checks for linearity. More recent work
\cite{DBLP:conf/ecoop/CledouEJP22} improves on the flexibility by
relying on advanced typing features in Scala~3.

\subsection{Rust}
\label{sec:rust}



Several recent implementations of session types \cite{DBLP:conf/ecoop/ChenBT22,DBLP:conf/ecoop/LagaillardieNY22,DBLP:conf/ppopp/CutnerYV22,DBLP:conf/coordination/CutnerY21,DBLP:conf/coordination/LagaillardieNY20,DBLP:journals/corr/abs-1909-05970,DBLP:conf/icfp/JespersenML15} rely on Rust, a
language with uniqueness types and ownership, all checked at compile
time. While uniqueness types are quite similar to affine types
(describing values that can be used at most once), they do not quite
get to the level needed for sessions: having an affine session type
for a channel means that an agent can drop the connection anytime
without finishing the protocol, which leads to deadlock at the other
end of the connection. With a proper linear session type, every agent has to
fulfil the protocol up to the closing of the connection.

% \cite{DBLP:conf/ecoop/ChenBT22}
% \cite{DBLP:conf/ecoop/LagaillardieNY22}
% \cite{DBLP:conf/ppopp/CutnerYV22}
% \cite{DBLP:conf/coordination/CutnerY21}
% \cite{DBLP:conf/coordination/LagaillardieNY20}
% \cite{DBLP:journals/corr/abs-1909-05970}
% \cite{DBLP:conf/icfp/JespersenML15}

\section{Conclusions}
\label{sec:conclusions}

Our paper demonstrates that a callback-based approach to
implementation session-typed programs is a perfect fit with (mildly)
dependently-typed functional programming. The intrinsically
session-typed way of writing program guarantees protocol fidelity and,
in some instances, deadlock freedom 
by construction. In connection with the callback approach, the host
language does not have to support linearity, so that programs are
statically safe, once the encapsulated library is verified.

Interestingly, the changed angle of attack revealed the possibility of
and the need for two novel constructions, the dynamic selection and
the {\AUNROLL} command for recursive sessions. The first one is
facilitated by our dependently-typed host language. The second one
arose from the need to write client programs for recursive protocols. 

The discussion in Section~\ref{sec:discussion} contains several
pointers for future work. It would also be interesting to investigate
ways to integrate subtyping (an obvious one being the insistence on
explicit coercions).

%%
%% The acknowledgments section is defined using the "acks" environment
%% (and NOT an unnumbered section). This ensures the proper
%% identification of the section in the article metadata, and the
%% consistent spelling of the heading.
% \begin{acks}
% To Robert, for the bagels and explaining CMYK and color spaces.
% \end{acks}

%%
%% The next two lines define the bibliography style to be used, and
%% the bibliography file.
\bibliographystyle{ACM-Reference-Format}
\bibliography{references}


%%
%% If your work has an appendix, this is the place to put it.
% \appendix


\end{document}
\endinput
%%
%% End of file `sample-acmsmall-submission.tex'.
