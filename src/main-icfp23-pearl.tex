\documentclass[acmsmall,screen,anonymous,review]{acmart}

\usepackage{agda}

%% There is a limit of 25 pages for a full paper or Functional Pearl
%% and 12 pages for an Experience Report; in either case, the
%% bibliography and an optional clearly marked appendix will not be
%% counted against these limits. Submissions that exceed the page
%% limits or, for other reasons, do not meet the requirements for
%% formatting, will be summarily rejected. 


%% Rights management information.  This information is sent to you
%% when you complete the rights form.  These commands have SAMPLE
%% values in them; it is your responsibility as an author to replace
%% the commands and values with those provided to you when you
%% complete the rights form.
\setcopyright{acmcopyright}
\copyrightyear{2023}
\acmYear{2023}
\acmDOI{XXXXXXX.XXXXXXX}


%%
%% These commands are for a JOURNAL article.
% \acmJournal{JACM}
% \acmVolume{37}
% \acmNumber{4}
% \acmArticle{111}
% \acmMonth{8}

%%
%% Submission ID.
%% Use this when submitting an article to a sponsored event. You'll
%% receive a unique submission ID from the organizers
%% of the event, and this ID should be used as the parameter to this command.
%%\acmSubmissionID{123-A56-BU3}

%%
%% For managing citations, it is recommended to use bibliography
%% files in BibTeX format.
%%
%% You can then either use BibTeX with the ACM-Reference-Format style,
%% or BibLaTeX with the acmnumeric or acmauthoryear sytles, that include
%% support for advanced citation of software artefact from the
%% biblatex-software package, also separately available on CTAN.
%%
%% Look at the sample-*-biblatex.tex files for templates showcasing
%% the biblatex styles.
%%

%%
%% The majority of ACM publications use numbered citations and
%% references.  The command \citestyle{authoryear} switches to the
%% "author year" style.
%%
%% If you are preparing content for an event
%% sponsored by ACM SIGGRAPH, you must use the "author year" style of
%% citations and references.
%% Uncommenting
%% the next command will enable that style.
%%\citestyle{acmauthoryear}


%%
%% end of the preamble, start of the body of the document source.
\input{unicodeletters}
\input{agdamacros}
\begin{document}

%%
%% The "title" command has an optional parameter,
%% allowing the author to define a "short title" to be used in page headers.
\title{How to Embed Session Types Without Linearity}
\subtitle{Functional Pearl}

%%
%% The "author" command and its associated commands are used to define
%% the authors and their affiliations.
%% Of note is the shared affiliation of the first two authors, and the
%% "authornote" and "authornotemark" commands
%% used to denote shared contribution to the research.
\author{Peter Thiemann}
% \authornote{Both authors contributed equally to this research.}
\email{thiemann@acm.org}
\orcid{0000-0002-9000-1239}
% \author{G.K.M. Tobin}
% \authornotemark[1]
% \email{webmaster@marysville-ohio.com}
\affiliation{%
  \institution{University of Freiburg}
  % \streetaddress{P.O. Box 1212}
  % \city{Dublin}
  % \state{Ohio}
  \country{Germany}
  % \postcode{43017-6221}
}

%%
%% By default, the full list of authors will be used in the page
%% headers. Often, this list is too long, and will overlap
%% other information printed in the page headers. This command allows
%% the author to define a more concise list
%% of authors' names for this purpose.
% \renewcommand{\shortauthors}{Trovato et al.}

%%
%% The abstract is a short summary of the work to be presented in the
%% article.
\begin{abstract}
  TBD
\end{abstract}

%%
%% The code below is generated by the tool at http://dl.acm.org/ccs.cfm.
%% Please copy and paste the code instead of the example below.
%%
% \begin{CCSXML}
% <ccs2012>
%  <concept>
%   <concept_id>10010520.10010553.10010562</concept_id>
%   <concept_desc>Computer systems organization~Embedded systems</concept_desc>
%   <concept_significance>500</concept_significance>
%  </concept>
%  <concept>
%   <concept_id>10010520.10010575.10010755</concept_id>
%   <concept_desc>Computer systems organization~Redundancy</concept_desc>
%   <concept_significance>300</concept_significance>
%  </concept>
%  <concept>
%   <concept_id>10010520.10010553.10010554</concept_id>
%   <concept_desc>Computer systems organization~Robotics</concept_desc>
%   <concept_significance>100</concept_significance>
%  </concept>
%  <concept>
%   <concept_id>10003033.10003083.10003095</concept_id>
%   <concept_desc>Networks~Network reliability</concept_desc>
%   <concept_significance>100</concept_significance>
%  </concept>
% </ccs2012>
% \end{CCSXML}

% \ccsdesc[500]{Computer systems organization~Embedded systems}
% \ccsdesc[300]{Computer systems organization~Redundancy}
% \ccsdesc{Computer systems organization~Robotics}
% \ccsdesc[100]{Networks~Network reliability}

%%
%% Keywords. The author(s) should pick words that accurately describe
%% the work being presented. Separate the keywords with commas.
\keywords{session types, domain specific languages, linear types}

% \received{20 February 2007}
% \received[revised]{12 March 2009}
% \received[accepted]{5 June 2009}

%%
%% This command processes the author and affiliation and title
%% information and builds the first part of the formatted document.
\maketitle

\section{Introduction}
\label{sec:introduction}

Session types provide a type discipline for structured communication
in concurrent programming systems.

We concentrate on binary session types, although our proposal should
be extensible to the multi-party setting.

For a long time, session types were inextricably connected to linear
types. This connection has affected their implementation and widespread
adoption. Languages constructed around session types embrace linearity
and their type checker rejects violations thereof. Examples: Links,
Sepi, Sill, C0, more?
While these languages and their implementation have fostered research
and encouraged experimentation, these languages are not widely used.

To boost the use of session types, 
a lot of work is dedicated to embedding session types in mainstream
languages, most of which do not have native support for linearity. 
(Plenty of examples with different trade-offs.)

Recent work on multi-party session types suggests an alternative
approach, reminiscent of the inversion of control approach which is
familiar to programmer from GUI programming. The system described in
that paper compiles a description of a multi-party session type into
a library that encapsulates the implementation of all
communication. For each communication action, the library provides an
interface where the programmer specifies a callback function for this
particular action.

We show how to apply this idea to binary session types in the context
of dependently-typed functional programming. Our vehicle is the
language Agda, so that our development is transferrable to Haskell,
either via compilation or via translation
\cite{DBLP:conf/haskell/CockxME0N22}.

TODO: Mention TCB (trusted computing base) in connection to linearity.

\section{Finite nonbranching session types}
\label{sec:finite-nonbr-simple}

\input{latex/ST-finite-nonbranching.tex}

Let's start straight away with the simplest instance, finite
nonbranching simple session types, to convey the
gist of the approach. Subsequent sections show how to add most of the
usual features of session types.

A binary session type describes a bidirectional communication between two peers,
let's call them server and client. The session type is attached to the
type of the communication channel.
\stFiniteType
\stFiniteSession
These types correspond to the standard grammar of session types, where
$T$ is the type of payloads that can be transmitted and $S$ is the
type of sessions. 
\begin{align*}
  T &::= \Aint \mid \Abool  & S &::= \Atsend{T}{S} \mid \Atrecv{T}{S} \mid \Atend
\end{align*}
The session type $\Atsend{T}{S}$ ($\Atrecv{T}{S}$) describes a channel that is ready to send (receive)
a value of payload type $T$ and the continue as $S$. The session type
$\Atend$ describes a channel that can only be closed.

Here are two examples for session types: the types of the server for a
binary operation and a unary operation, respectively.
\stExampleBinpUnP

In standard session type theory \cite{???}, there are primitives to
send and receive values and to close a channel with types like this:
\begin{align*}
  \mathtt{send} & : \Atsend{T}{S} \otimes T \multimap S &
                                                   \mathtt{recv} &:
                                                                   \Atrecv{T}{S}
                                                                   \multimap
                                                                   (T
                                                                   \otimes
                                                                   S)
  & \mathtt{close} &: \Atend \multimap ()
\end{align*}
The types indicate that we must treat channel values of type $S$
\emph{linearly}: the \texttt{send} operation \emph{consumes} a
channel, which is ready to send, and returns it in a state described
by $S$; the \texttt{recv} operation \emph{consumes} a channel, which
is ready to receive, and returns a pair with the received value and
the updated channel; the \texttt{close} operation \emph{consumes} the
channel and returns a unit value. Enforcing this linearity is required
for soundness.

We take a different approach inspired by programming with
callbacks. Instead of providing \texttt{send} and \texttt{recv}
primitives to the programmer, we ask the programmer to define the
``application logic'' by implementing a value whose type {\ACommand} is indexed by
a session type. This definition relies on an interpretation of
types as Agda types.
\stTypeInterpretation
\stCommand
In this definition, the type $A$ embodies the application state. 
Each $\ACSEND$ command takes a state transformer that extracts the value to
send from the current application state; each $\ACRECV$ command takes
a state transformer that is indexed by the received value; the $\ACEND$
command terminates the session. In fact, we could provide the
application logic by actions in a state monad over the application
state $A$. We defer the shift to a monadic interface to Section~\ref{sec:going-monadic},
when we have the full picture.

Continuing our example, we define commands that implement a server
for the protocols {\Abinaryp} and {\Aunaryp} with the operation instantiated to
addition and negation, respectively.
\stAddpCommand
We use explicit lambda abstraction instead of (more fancy) combinators
for clarity; the variable $a$ stands for the application state and $x$ and $y$ for
the respective values received from the channel. 

To execute commands, we write an
interpreter that relies on primitive operations provided
in the $\AIO$ monad. The point of our approach is that this
interpreter is the single definition where we are obliged to prove
that it handles channels in a linear fashion. 
\stPostulates
This API should be self-explanatory. It declares an abstract type of
channels with operations to accept a connection, close a channel, as
well as send and receive a value over the channel. It glosses over issues like
serialization, which can be addressed using type classes.
% Our shared memory implementation relies on unsafe casts.

The interpreter itself is defined by induction on the type
{\ACommand}.
\stExecutorSignature\vspace{-1.5\baselineskip}
\stExecutor
To actually run a server, it remains to provide a wrapper that accepts
a connection and invokes the interpreter.
\stAcceptor
Examining the interpreter, we finally see the full monadic
structure. We need a stack of monad transformers starting with a state
monad for the application state on top of a reader monad providing the
channel on top of the IO monad. 

\section{Selection and choice}
\label{sec:select-choice}

Adding branching to our development is straightforward. The standard
theory allows branching on a finite set of labels using this syntax:
\begin{align*}
  S & ::= \dots \mid \oplus\{ \ell : S_\ell \mid \ell \in L \} \mid
      \&\{\ell: S_\ell \mid \ell \in L\}
\end{align*}
Here $L$ is a finite set of labels, which can be chosen differently at
every instance. 
The type constructor $\oplus$ corresponds to an \emph{internal choice} of the
program.  The \texttt{select} primitive sends one of the labels, say $\ell \in L$, available in the
type and continues according to $S_\ell$:
\begin{align*}
  \mathtt{select}\ \ell &: \oplus\{ \ell : S_\ell \mid \ell \in L \}
                          \multimap S_\ell
\end{align*}
The type constructor $\&$ corresponds to an \emph{external choice}. The
primitive \texttt{branch} receives one of the labels 
mentioned in the type and chooses a continuation according to the
label. In the presence of sum types, the primitive can be typed as
follows \cite{DBLP:journals/toplas/Padovani19}.
\begin{align*}
  \mathtt{branch} &: \&\{\ell: S_\ell \mid \ell \in L\} \multimap +\{\ell: S_\ell \mid \ell \in L\}
\end{align*}
The modeling in Agda extends the definitions of
{\ASession}, {\ACommand}, and {\Aexecutor} from
Section~\ref{sec:finite-nonbr-simple}. A label set of size $n$ is
modeled by the type $\AFin~n$ and the alternative continuation sessions by
functions from labels to {\ASession} (isomorphic to vectors of sessions, cf.\  Section~\ref{sec:select-choice-with}).
\stBranchingType
\stBranchingCommand
\stExecutorSignature\vspace{-1.5\baselineskip}
\stBranchingExecutor

Continuing our example, we define the type of an arithmetic server,
which gives a choice between a binary operation and a unary one. 
This definition uses a smart constructor for the external choice that
takes a vector and transforms it into the corresponding function.
\stExampleArithP
The command for the server extends in the obvious way. The vector
trick does not work for the {\ACommand} constructors {\ACSELECT} and
{\ACCHOICE} because their arguments are dependent functions that
generally return different types for different arguments.
\stArithpCommand

\section{Going in circles}
\label{sec:going-circles}
\input{latex/ST-recursive.tex}

Recursive types are a common feature of session types. They are required
to model protocols for servers that perform the same functionality
over and over again. Our running example will be a server that allows
a client to repeatedly perform a unary operation until the client
quits.

The pen-and-paper syntax of recursive types relies on type variables
and a $\mu$ operator like so:\footnote{We gloss over the issue of
  guardedness (or contractiveness) for recursive types to avoid further complexity in the
  types.}
\begin{align*}
  S &::= \Atsend{T}{S} \mid \Atrecv{T}{S} \mid \Atend \mid
      \Amu~X. S
      \mid X
      \mid \dots
\end{align*}
The intended semantics of the $\Amu$ operator is that $\Amu~X.S$ is
isomorphic to $S[X \mapsto \Amu~X.S]$, the unfolding, where we
substitute the recursive type itself for the variable $X$ in its body.

For the Agda formalization we choose the standard de Bruijn encoding
of bound variables. The parameter $n$ of
the {\ASession} type denotes the number of type variables in
scope. The {\Amu} operator opens a new scope and {\Aback~$i$}
references the $i$th variable, the innermost binding being $0$.
\rstSession

Extending our running example, we redefine the protocol {\Aunaryp} as a function
that takes the rest of the protocol and wrap it into a recursive
type. The session type {\Amanyunaryp} is a recursive type that either
runs a unary function and recurses or just ends the protocol. We
define $\&$ as a smart constructor as in Section~\ref{sec:select-choice}.
\rstExampleManyUnaryp

The {\ACommand} type is straightforward to extend. It obtains a new
parameter $n$ to match the parameter of the session type used as an
index. We only show the two new cases.
\rstCommand

With this type we are ready to implement a
service that repeatedly adds numbers as they are received and sends the partial
sum as a response each time.
\rstSumupCommand

Executing a command with recursion requires a new component in the
executor. Whenever execution enters a {\AMU} command, this component
saves the body of the {\AMU} in a stack. Upon a {\ACONTINUE~$i$}
command, we grab the corresponding loop body from the stack and
continue with it. There are a few complications in setting up this new
component that we call {\ACommandStore}.

\begin{figure}[tp]
  \begin{align*}
    &
      \begin{array}{|ll|}
        0 &\mapsto \ASession~1
      \end{array}
    &&
      \begin{array}{|ll|}
        0 &\mapsto \ASession~2 \\
        1 &\mapsto \ASession~1
      \end{array}
          &&
             \dots
    &&
       \begin{array}{|ll|}
         0 & \mapsto \ASession~(1+n) \\
         1 & \mapsto \ASession~n \\
           & \vdots \\
         n-1 & \mapsto \Asession~1
       \end{array}
  \end{align*}
  \caption{The {\ACommandStore} after 1, 2, and $n$ loop entries}
  \label{fig:commandstore}
\end{figure}
First, its type is non-obvious.  The top-level type is a
{\ASession~0}. When we enter the first loop, its body refers to a
session of type {\ASession~1}. Hence, the {\ACommandStore} contains
one entry (first table in Figure~\ref{fig:commandstore}).
Entering the next loop pushes a body for the type {\ASession~2}
(middle of figure). After entering the $n$-th loop, we obtain the
picture on the right of Figure~\ref{fig:commandstore}. Here is a
suitable type definition.
\rstCommandStore

For some $(i : \AFin~(\Asuc~ n))$, the function
$\AgdaFunction{opposite}~i$ returns $n-i$ (as an element of the same
type). The tricky part is implemented the typed push and pop operations on
that structure.
\rstPops

The \AgdaFunction{pop1} function pops the first entry off the
{\ACommandStore}. It gets used in defining the inductive step of the
function tele
\AgdaFunction{pop}, which pops any (legal) number of entries
from the stack. The proofs are short but technical. They involve
injections from $\AFin~n$ to $\AFin~(\Asuc~n)$.

\rstExecutorSignature\vspace{-1.5\baselineskip}
\rstExecutor

The execution of {\AMU} just pushes the loop body onto the
{\ACommandStore}, again with minor technical complications due to the
{\AFin} type --- just ignore the \AgdaKeyword{rewrite} to see what is
happening.

The case for {\ACONTINUE~$i$} reveals another complication. The recursive
call happens on a command drawn from the {\ACommandStore}. This
command is unrelated to the current command, which upsets Agda's
termination checker. To console it we introduce a \AgdaType{Gas}
argument, which we decrement at each {\ACONTINUE}.

The question is, what to do if we run out of gas?
There are at least three possibilities.
\begin{enumerate}
\item We regard the current formalization as a proof of concept and
  refer the reader to a ``real'' implementation in Haskell, where the
  \AgdaType{Gas} argument is not required. We see no
  problem in creating such an implementation, but it would be more
  involved as dependent types are not yet fully integrated in Haskell.
\item We turn the bug into a feature and require that every
  {\ACONTINUE} communicates with the other end of the channel to
  exchange their respective gas levels and quit the loop if one end
  runs out of gas. This choice implies that we would have to a
  continuation argument to  {\ACONTINUE} that acts like a
  finally-clause for exception and finishes the protocol in an orderly
  way.
\item We can modify {\Aexecutor} so that it always takes a single step
  and returns either a continuation and an intermediate state or a
  final result of type $A$. This modification is straightforward in 
  the setting with loops as a value \AgdaFunction{cms} of type {\ACommandStore~$(\Asuc~n)$~$A$}
  can serve as a continuation. To restart a continuation, we simply invoke
  {\Aexecutor} on \AgdaFunction{cms}~\Azero. For concreteness, we show
  the continuation type and an implementation of the restart function.
  \rstAlternativeExecutorRestart
  With this approach, the management of {\Arestart}  has to be
  included in the TCB as it also has to guarantee linear treatment of
  the channel.
\end{enumerate}
The current formalization leaves that question open and just breaks
the protocol. Our preferred solution is a Haskell implementation,
which omits the gas and thus sticks to the protocol.

\newpage
\section{Going monadic}
\label{sec:going-monadic}

We already remarked about the monadic structure apparent in the
callbacks and in the implementation of the {\Aexecutor}
function. Indeed, moving on to a monadic interface makes our session
programs more concise.



\newpage

\section{Discussion}
\label{sec:discussion}

\subsection{Command fragments}
\label{sec:command-fragments}


Instead of having commands indexed by session types, we could have
\emph{command fragments} indexed by transformations of session types
($S \to S$). Everything is definable in this way, but defining
protocols is awkward as the type checker is unable to provide
guidance.

Here is an example: (elaborate)

\subsection{Selection and choice with vectors}
\label{sec:select-choice-with}

The reader may wonder why we do not define the constructors for
selection and choice using vectors of length $n$, rather than
functions from $\AFin~n$ (which is isomorphic). Using function extends
straightforwardly to the definition of {\ACommand} where the {\ASession} index of the
continuation command depends on the function argument $i : \AFin~n$.
We would have to define a special vectors type to achieve similar
expressivity. 

%%
%% The acknowledgments section is defined using the "acks" environment
%% (and NOT an unnumbered section). This ensures the proper
%% identification of the section in the article metadata, and the
%% consistent spelling of the heading.
% \begin{acks}
% To Robert, for the bagels and explaining CMYK and color spaces.
% \end{acks}

%%
%% The next two lines define the bibliography style to be used, and
%% the bibliography file.
\bibliographystyle{ACM-Reference-Format}
\bibliography{references}


%%
%% If your work has an appendix, this is the place to put it.
% \appendix


\end{document}
\endinput
%%
%% End of file `sample-acmsmall-submission.tex'.
