\documentclass[acmsmall,screen,anonymous,review]{acmart}

\usepackage{agda}
\usepackage{stmaryrd}
\usepackage{listings}

%% There is a limit of 25 pages for a full paper or Functional Pearl
%% and 12 pages for an Experience Report; in either case, the
%% bibliography and an optional clearly marked appendix will not be
%% counted against these limits. Submissions that exceed the page
%% limits or, for other reasons, do not meet the requirements for
%% formatting, will be summarily rejected. 


%% Rights management information.  This information is sent to you
%% when you complete the rights form.  These commands have SAMPLE
%% values in them; it is your responsibility as an author to replace
%% the commands and values with those provided to you when you
%% complete the rights form.
\setcopyright{acmcopyright}
\copyrightyear{2023}
\acmYear{2023}
\acmDOI{XXXXXXX.XXXXXXX}


%%
%% These commands are for a JOURNAL article.
% \acmJournal{JACM}
% \acmVolume{37}
% \acmNumber{4}
% \acmArticle{111}
% \acmMonth{8}

%%
%% Submission ID.
%% Use this when submitting an article to a sponsored event. You'll
%% receive a unique submission ID from the organizers
%% of the event, and this ID should be used as the parameter to this command.
%%\acmSubmissionID{123-A56-BU3}

%%
%% For managing citations, it is recommended to use bibliography
%% files in BibTeX format.
%%
%% You can then either use BibTeX with the ACM-Reference-Format style,
%% or BibLaTeX with the acmnumeric or acmauthoryear sytles, that include
%% support for advanced citation of software artefact from the
%% biblatex-software package, also separately available on CTAN.
%%
%% Look at the sample-*-biblatex.tex files for templates showcasing
%% the biblatex styles.
%%

%%
%% The majority of ACM publications use numbered citations and
%% references.  The command \citestyle{authoryear} switches to the
%% "author year" style.
%%
%% If you are preparing content for an event
%% sponsored by ACM SIGGRAPH, you must use the "author year" style of
%% citations and references.
%% Uncommenting
%% the next command will enable that style.
%%\citestyle{acmauthoryear}


%%
%% end of the preamble, start of the body of the document source.
\input{unicodeletters}
\input{agdamacros}

%% listings
\lstset{
  language=haskell,
  basicstyle=\ttfamily,
  morekeywords={send,recv,close,send_on_,receive,End,Int,Chan},
  captionpos=b,
  literate=
  {-o}{${\multimap}$}1
  {ex}{$\exists$}1
  {all}{$\forall$}1
  {\\x}{$\times$}1
  %{(x)}{$\otimes$}1
  {fresh}{$\lozenge$}1
  {~~}{$\approx$}1
}

\begin{document}

%%
%% The "title" command has an optional parameter,
%% allowing the author to define a "short title" to be used in page headers.
\title{How to Embed Session Types Without Linearity}
\subtitle{Functional Pearl}

%%
%% The "author" command and its associated commands are used to define
%% the authors and their affiliations.
%% Of note is the shared affiliation of the first two authors, and the
%% "authornote" and "authornotemark" commands
%% used to denote shared contribution to the research.
\author{Peter Thiemann}
% \authornote{Both authors contributed equally to this research.}
\email{thiemann@acm.org}
\orcid{0000-0002-9000-1239}
% \author{G.K.M. Tobin}
% \authornotemark[1]
% \email{webmaster@marysville-ohio.com}
\affiliation{%
  \institution{University of Freiburg}
  % \streetaddress{P.O. Box 1212}
  % \city{Dublin}
  % \state{Ohio}
  \country{Germany}
  % \postcode{43017-6221}
}

%%
%% By default, the full list of authors will be used in the page
%% headers. Often, this list is too long, and will overlap
%% other information printed in the page headers. This command allows
%% the author to define a more concise list
%% of authors' names for this purpose.
% \renewcommand{\shortauthors}{Trovato et al.}

%%
%% The abstract is a short summary of the work to be presented in the
%% article.
\begin{abstract}
  TBD
\end{abstract}

%%
%% The code below is generated by the tool at http://dl.acm.org/ccs.cfm.
%% Please copy and paste the code instead of the example below.
%%
% \begin{CCSXML}
% <ccs2012>
%  <concept>
%   <concept_id>10010520.10010553.10010562</concept_id>
%   <concept_desc>Computer systems organization~Embedded systems</concept_desc>
%   <concept_significance>500</concept_significance>
%  </concept>
%  <concept>
%   <concept_id>10010520.10010575.10010755</concept_id>
%   <concept_desc>Computer systems organization~Redundancy</concept_desc>
%   <concept_significance>300</concept_significance>
%  </concept>
%  <concept>
%   <concept_id>10010520.10010553.10010554</concept_id>
%   <concept_desc>Computer systems organization~Robotics</concept_desc>
%   <concept_significance>100</concept_significance>
%  </concept>
%  <concept>
%   <concept_id>10003033.10003083.10003095</concept_id>
%   <concept_desc>Networks~Network reliability</concept_desc>
%   <concept_significance>100</concept_significance>
%  </concept>
% </ccs2012>
% \end{CCSXML}

% \ccsdesc[500]{Computer systems organization~Embedded systems}
% \ccsdesc[300]{Computer systems organization~Redundancy}
% \ccsdesc{Computer systems organization~Robotics}
% \ccsdesc[100]{Networks~Network reliability}

%%
%% Keywords. The author(s) should pick words that accurately describe
%% the work being presented. Separate the keywords with commas.
\keywords{session types, domain specific languages, dependent types, Agda}

% \received{20 February 2007}
% \received[revised]{12 March 2009}
% \received[accepted]{5 June 2009}

%%
%% This command processes the author and affiliation and title
%% information and builds the first part of the formatted document.
\maketitle

\section{Introduction}
\label{sec:introduction}

\input{latex/ST-finite-nonbranching.tex}

Session types provide a type discipline for protocols
in concurrent programming systems. Each session type operator
describes the direction of communication and the type of the
payload (the transmitted value). Moreover, there are ways to specify
control structures for protocols like sequencing, branching, and
looping.

Honda and others
\cite{DBLP:conf/concur/Honda93,DBLP:conf/parle/TakeuchiHK94,DBLP:conf/esop/HondaVK98}
started the investigation of session types originally in the context
of the pi-calculus \cite{DBLP:journals/iandc/MilnerPW92a}. Later the concepts were adapted to other programming
paradigms like functional programming
\cite{DBLP:journals/tcs/VasconcelosGR06,DBLP:journals/jfp/GayV10} and
object-oriented programming
\cite{DBLP:conf/europar/RavaraV97,DBLP:journals/corr/abs-1205-5344}. 

The early works concentrated on binary session types, i.e., protocols
with two parties. Subsequently, multi-party session types were
proposed \cite{DBLP:journals/jacm/HondaYC16} that relax the
restriction to two parties. The Betty project resulted in several survey articles
and books that provide a good overview of the field
\cite{gay17:_behav_types,DBLP:journals/csur/HuttelLVCCDMPRT16,DBLP:journals/jlp/BartolettiCDDGP15,DBLP:journals/ftpl/AnconaBB0CDGGGH16}. 
For this paper, we mostly focus the discussion on the binary case, but draw some
inspiration from multi-party session types.


Session types are inextricably connected to linear types via the
Curry-Howard correspondence. This connection has been discovered and
investigated in quite some depth
\cite{DBLP:conf/concur/CairesP10,DBLP:journals/mscs/CairesPT16,DBLP:journals/jfp/Wadler14}
along with many ramifications \cite{DBLP:journals/pacmpl/BalzerP17}. 
Moreover, this connection is not just of theoretical interest, but it
has affected the implementation and (one could argue) hampered widespread
adoption. Languages constructed around session types are usually
special purpose languages that embrace linearity so that their type
checker rejects violations thereof. Examples are plenty: Links \cite{lindley17:_light_funct_session_types},
Sepi \cite{DBLP:conf/sefm/FrancoV13,DBLP:conf/sfm/Vasconcelos09}, Sill
\cite{DBLP:conf/esop/ToninhoCP13}, C0
\cite{DBLP:journals/corr/WillseyPP17}, and so on.
While these languages and their implementation have fostered research
and encouraged experimentation, they are not widely used.

To boost the use of session types, 
a lot of work has been dedicated to embedding session types in mainstream
languages, most of which do not have native support for linearity. 
There are plenty of examples for such embeddings for functional languages
like
Haskell \cite{DBLP:conf/padl/NeubauerT04,SackmanE08,
  DBLP:conf/haskell/PucellaT08} and
OCaml \cite{DBLP:journals/jfp/Padovani17,DBLP:journals/scp/ImaiYY19},
as well as object-oriented languages like
C\# \cite{DBLP:journals/corr/abs-2004-01325},
Scala \cite{DBLP:conf/ecoop/ScalasY16},
Java \cite{DBLP:conf/ecoop/HuYH08}. Most of these approaches ignore
the issue of linearity at compile time; some ignore it entirely. Some (e.g., \cite{DBLP:journals/jfp/Padovani17}) rely
on run-time checks, others rely on encodings of linearity using lenses
\cite{DBLP:journals/jip/ImaiG19} or monads \cite{DBLP:conf/haskell/PucellaT08}.
There are also extension languages with a separate checker that add
sessions \cite{DBLP:conf/coordination/NgYPHK11} or, more generally,
typestate \cite{DBLP:journals/scp/KouzapasDPG18} to an underlying Java program.
We comment on some recent implementation that rely on Rust in the
related work (Section~\ref{sec:related-work}).

Recent work on multi-party session types
\cite{DBLP:conf/cc/Miu0Y021,DBLP:journals/pacmpl/00020HNY20} suggests
an alternative approach that does not rely on linearity. It is
inspired by the design principle \emph{inversion of control} which is
familiar to programmers from GUI programming. The systems described in
those works translate a description of a multi-party session type into
a library that encapsulates the implementation of all
communication. For each communication action, the library provides an
interface where the programmer specifies a callback function for this
particular action.

To clarify this idea, we give a very simple example, continued and
extended in Section~\ref{sec:finite-nonbr-simple}, in the context of a
functional language. Unlike the cited
work, our work as well as this example rely on \emph{binary} session
types. We start with the following grammar for types $T$ and session
types $S$.
\begin{align*}
  T &::= \Aint \mid \Abool  & S &::= \Atsend{T}{S} \mid \Atrecv{T}{S} \mid \Atend
\end{align*}
The session type $\Atsend{T}{S}$ ($\Atrecv{T}{S}$) describes a channel that is ready to send (receive)
a value of payload type $T$ and the continue as $S$. The session type
$\Atend$ describes a channel that can only be closed.

\begin{description}
\item[Traditional setting] (cf.\ \cite{DBLP:journals/jfp/GayV10}) The
  traditional interface to session-typed communication consists of primitive
  operations like
  \begin{align*}
  \mathtt{send} & : \Atsend{T}{S} \otimes T \multimap S &
                                                   \mathtt{recv} &:
                                                                   \Atrecv{T}{S}
                                                                   \multimap
                                                                   (T
                                                                   \otimes
                                                                   S)
    & \mathtt{close} &: \Atend \multimap ()
  \end{align*}
  that send on a channel, receive from a channel, and close a channel.
  The crucial observation is that the type system must treat channels
  linearly to ensure protocol fidelity.

  Programs typically look like this:
\begin{lstlisting}
negp-server : ?int.!int.end -o ()
negp-server  c0 =                    -- c0 : ?int.!int.end
  let (x, c1) = recv c0 in           -- c1 :      !int.end
  let c2 = send (c1, -x) in          -- c2 :           end
  close c2
\end{lstlisting}
By linearity, the \texttt{recv} operation consumes \texttt{c0};
otherwise, another \texttt{recv} could be applied, thus breaking the
protocol.
Analogous arguments apply to \texttt{c1} and \texttt{c2}.
\item[Callback approach] The callback interface to session-typed
  communication proposed in this work consists of a datatype of commands, {\ACommand}, indexed by an
  application state $A$ and a
  session type. Moreover, there is an encapsulated interpreter
  {\Aexecutor} to  execute commands.\footnote{For all details see Section~\ref{sec:finite-nonbr-simple}.} 
\stCommand

  The {\ACSEND} command has a callback to obtain the value to be sent
  from the application state. Similarly, the {\ACRECV} command has a
  callback to inject the received value in the application state. Both
  take a continuation command of type {\ACommand~$A$~$S$} that deals
  with the continuation session $S$.

  A program looks similar to the traditional one where we choose
  {\AZ}, the integers, as the application state.
\stNegpCommand

  The least sophisticated interpreter takes a command, a suitable
  initial application state, an untyped channel, and results in an IO
  action that produces the final application state.
\stExecutorSignature

  This interpreter is implemented once and for all in an encapsulated
  library. In a sense, it forms the trusted computing base of our
  approach, as we have the obligation to prove that it performs the
  commands on the channel according to the session type index of the
  channel. 
\end{description}

\subsection{Contributions}
\label{sec:contributions}

\begin{itemize}
\item We show how to deploy the callback approach to binary session
  types in the context of dependently-typed functional
  programming. Our vehicle is the language Agda, but we expect our
  development to be transferrable to Haskell, either via compilation or via translation
  \cite{DBLP:conf/haskell/CockxME0N22}.
\item Linearity of session handling is ensured by verifying linear
  handling of command execution in a small interpreter that forms the
  trusted computing base of our approach. No affine
  types or linear types are needed in the type system of the host
  language.
\item We demonstrate that the approach extends to most familiar
  session type constructions: branching
  (Section~\ref{sec:select-choice}), recursion
  (Section~\ref{sec:going-circles}), higher-order sessions.
\item The extension to operate on multiple channels is significant and
  mostly orthogonal to the other features. Interestingly, it requires
  several elements of multiparty session types.
\item We propose a new dynamic selection operation in the context of
  branching session types (Section~\ref{sec:select-choice}).
\item We extend the callback approach to context-free session types
  (with branching and recursion), which in turn requires a more
  sophisticated, dependently-typed encoding of commands than regular
  session types.
\item All our session type systems inherit the polymorphism from their
  host language, Agda.
\item For monad lovers we describe version with a monadic encoding of callbacks.
\end{itemize}

The source of this document includes a number of literate Agda
scripts which will be submitted as an anonymized supplement (to be
turned into an artifact). Every line of code that is typeset in color
has been checked by Agda.


Working knowledge of Agda is not a hard requirement for understanding the
paper. We strive to make the code accessible to readers who are
knowledgable in Haskell by explaining features specific
to Agda as they are encountered.

\section{Finite nonbranching session types}
\label{sec:finite-nonbr-simple}


Let's start straight away with the simplest instance, finite
nonbranching simple session types, to convey the
gist of the approach. Subsequent sections show how to add most of the
usual features of session types.

A binary session type describes a bidirectional communication between two peers,
let's call them server and client. The session type is attached to the
type of the communication channel.\footnote{Agda supports a mixfix
  syntax where underlines in the identifier indicate the position of
  the arguments. For example,  $\Atsend{\_}{\_}$ and $\Atrecv{\_}{\_}$ are operators with two
  arguments. We declare these operators to associate to the right to
  save parentheses.}
\stFiniteType
\stFiniteSession
These types correspond to the standard grammar of session types, where
$T$ is the type of payloads that can be transmitted and $S$ is the
type of sessions. 
\begin{align*}
  T &::= \Aint \mid \Abool  & S &::= \Atsend{T}{S} \mid \Atrecv{T}{S} \mid \Atend
\end{align*}
The session type $\Atsend{T}{S}$ ($\Atrecv{T}{S}$) describes a channel that is ready to send (receive)
a value of payload type $T$ and then continue as $S$. The session type
$\Atend$ describes a channel that can only be closed.

Here are two examples for session types: the types of the server for a
binary operation and a unary operation, respectively.
\stExampleBinpUnP

In a popular functional session type theory \cite{DBLP:journals/jfp/GayV10}, there are primitives to
send and receive values and to close a channel with types like this:
\begin{align*}
  \mathtt{send} & : (\Atsend{T}{S} \otimes T) \multimap S &
                                                   \mathtt{recv} &:
                                                                   \Atrecv{T}{S}
                                                                   \multimap
                                                                   (T
                                                                   \otimes
                                                                   S)
  & \mathtt{close} &: \Atend \multimap ()
\end{align*}
The types indicate that we must treat channel values of session type
\emph{linearly}: the \texttt{send} operation \emph{consumes} a
channel, which is ready to send, paired with the payload and returns it in a state described
by $S$; the \texttt{recv} operation \emph{consumes} a channel, which
is ready to receive, and returns a pair with the received value and
the updated channel; the \texttt{close} operation \emph{consumes} the
channel and returns a unit value. Enforcing this linearity is required
for soundness.

In this work, we take a different approach inspired by programming with
callbacks. Instead of providing \texttt{send} and \texttt{recv}
primitives to the programmer, we ask the programmer to define the
``application logic'' by implementing a command value whose type {\ACommand} is indexed by
a session type. This definition relies on an interpretation of
types as Agda types.
\stTypeInterpretation
\stCommand
In this definition, the type parameter $A$ embodies the application state. 
Each $\ACSEND$ command takes a state transformer that extracts the value to
send from the current application state; each $\ACRECV$ command takes
a state transformer that is indexed by the received value; the $\ACEND$
command terminates the session. In fact, we could provide the
application logic by actions in a state monad over the application
state $A$. We defer the shift to a monadic interface to Section~\ref{sec:going-monadic},
when we have the full picture.

Continuing our example, we define commands that implement a server
for the protocols {\Aunaryp} and {\Abinaryp} with the operation instantiated to
negation and addition, respectively.
\stNegpCommand
\stAddpCommand  
 We use explicit lambda abstraction instead of fancy abbreviations and library combinators
for clarity; the variable $a$ stands for the application state and $x$ and $y$ for
the respective values received from the channel. For connoisseurs of pointfree definitions, we give a
more concise version of the addition command using functions from the
standard library:
\stAddpCommandAlternative

To execute commands, we write an
interpreter that relies on primitive operations provided
in the $\AIO$ monad. The point of our approach is that this
interpreter is the single definition where we are obliged to prove
that it handles channels in a linear fashion. 
\stPostulates
This API should be self-explanatory.\footnote{The type $\top$ is like
  Haskell's unit type with single element {\Att}.} It declares an abstract type of
untyped, raw channels with operations to accept a connection, close a channel, as
well as send and receive a value over the channel. It glosses over issues like
serialization, which can be addressed using type class constraints like
{\ASerialize~$A$} (in Haskell) on {\AprimSend} and {\AprimRecv}.
% Our shared memory implementation relies on unsafe casts.

The interpreter itself is defined by induction on the type
{\ACommand}. The actual computation takes place in the {\AIO} monad and is expressed using the {\Ado} notation, both
familiar from Haskell. 
\stExecutorSignature\vspace{-1.5\baselineskip}
\stExecutor
To actually run a server, it remains to provide a wrapper that accepts
a connection and invokes the interpreter.
\stAcceptor
Examining the interpreter, we finally see the full monadic
structure. We need a stack of monad transformers starting with a state
monad for the application state on top of a reader monad providing the
channel on top of the IO monad.

Our proof obligation for the interpreter boils down to verifying that
the interpretation of each command executes the single communication
action designated by the corresponding session type operator. The
correct sequencing according to the session type is imposed by the
sequencing constraint underlying the {\AIO} monad. Indeed, this
observation was the key to employ monads for APIs to state-based
operations in pure functional languages \cite{DBLP:conf/popl/JonesW93}.

\section{Selection and choice}
\label{sec:select-choice}

Adding branching to our development is straightforward. The standard 
theory of session types allows branching on a finite set of labels using this syntax:
\begin{align*}
  S & ::= \dots \mid \oplus\{ \ell : S_\ell \mid \ell \in L \} \mid
      \&\{\ell: S_\ell \mid \ell \in L\}
\end{align*}
Here $L$ is a finite, non-empty set of labels, which can be chosen differently at
every use of the type operator. 
The type constructor $\oplus$ corresponds to an \emph{internal choice} of the
program.  The \texttt{select} primitive sends one of the labels, say $\ell \in L$, available in the
type and continues according to $S_\ell$:
\begin{align*}
  \mathtt{select}\ \ell &: \oplus\{ \ell : S_\ell \mid \ell \in L \}
                          \multimap S_\ell
\end{align*}
The type constructor $\&$ corresponds to an \emph{external choice}. The
primitive \texttt{branch} receives one of the labels 
mentioned in the type and chooses a continuation according to the
label. In the presence of sum types and linearity, the primitive can be typed as
follows \cite{DBLP:journals/toplas/Padovani19}.
\begin{align*}
  \mathtt{branch} &: \&\{\ell: S_\ell \mid \ell \in L\} \multimap +\{\ell: S_\ell \mid \ell \in L\}
\end{align*}
Our modeling in Agda extends the definitions of
{\ASession}, {\ACommand}, and {\Aexecutor} from
Section~\ref{sec:finite-nonbr-simple}. A label set of size $k$ is
modeled by the type $\AFin~k = \{ 0, \dots, k-1\}$ and the alternative continuation sessions by
functions from labels to {\ASession} (isomorphic to vectors of sessions, cf.\  Section~\ref{sec:select-choice-with}).
\stBranchingType
\stBranchingCommand
The commands for {\ACSELECT} and {\ACCHOICE} only differ in the
placement of the parentheses: {\ACSELECT} takes a label and a command
corresponding to this label, whereas {\ACCHOICE} takes a function that
maps a label to its command. Neither command requires the application
state: the selection is static and does not depend on the current
state; once the external choice has been taken, the chosen command can
reflect that choice in the application state.
\stExecutorSignature\vspace{-1.5\baselineskip}
\stBranchingExecutor

Extending our running example, we define the type of an arithmetic server,
which gives a choice between a binary operation and a unary one. 
This definition uses a smart constructor {\Aamp} for the external choice that
takes a vector of session types and transforms it into the
corresponding function.\footnote{This transformation relies on the
  isomorphism between vectors of size $k$ and non-dependent functions with domain {\AFin~$k$}.}
\stExampleArithP
The command for the server extends in the obvious way. The vector
trick does not work for the {\ACommand} constructors {\ACSELECT} and
{\ACCHOICE} because their arguments are dependent functions that
generally return different types for different arguments.
\stArithpCommand

Finally, we observe that the proposed interface enables a more dynamic
selection operator than in standard session types. While the standard
select operator is indexed by a label that is fixed at compile time,
we can supply a dynamic selector command where the label is computed
by a callback \AgdaFunction{getl} at run time:
\stDynamicBranchingCommand
Extending {\Aexecutor} to this command is straightforward.
There is still room for improvement in the type of this command. We
come back to this issue in Section~\ref{sec:context-free-session}.

\section{Going in circles}
\label{sec:going-circles}
\input{latex/ST-recursive.tex}

Recursive types are a common feature of session types. They are required
to model protocols for servers that perform the same functionality
over and over again. Our running example will be a server that allows
a client to repeatedly perform a unary operation until the client
quits.

The pen-and-paper syntax of recursive types relies on type variables
and a $\mu$ operator like so:\footnote{We gloss over the issue of
  guardedness (or contractiveness) for recursive types to avoid further complexity in the
  types.}
\begin{align*}
  S &::= \Atsend{T}{S} \mid \Atrecv{T}{S} \mid \Atend \mid
      \Amu~X. S
      \mid X
      \mid \dots
\end{align*}
The intended semantics of the $\Amu$ operator is that $\Amu~X.S$ is
equivalent to $S[X \mapsto \Amu~X.S]$, the unfolding, where we
substitute the recursive type itself for the variable $X$ in its body.

For the Agda formalization we choose the standard de Bruijn encoding
of bound variables. The parameter $n$ of
the {\ASession} type denotes the number of type variables in
scope. The {\Amu} operator opens a new scope and {\Aback~$i$}
references the $i$th variable, the innermost binding being $0$.
\rstSession

Further extending our running example, we redefine the protocol {\Aunaryp} as a function
that takes the rest of the protocol and wrap it into a recursive
type. The session type {\Amanyunaryp} is a recursive type that either
runs a unary function and recurses or just ends the protocol. We
define {\Aamp} as a smart constructor as in Section~\ref{sec:select-choice}.
\rstExampleManyUnaryp

The {\ACommand} type is straightforward to extend. It obtains a new
parameter $n$ to match the parameter of the session type used as an
index. We only show the two new cases.
\rstCommand

With this type we are ready to implement a
service that repeatedly adds numbers as they are received and sends the partial
sum as a response each time.
\rstSumupCommand

Executing a command with recursion requires a new component in the
executor. Whenever execution enters a {\AMU} command, this component
saves the body of the {\AMU} in a stack. Upon a {\ACONTINUE~$i$}
command, we grab the corresponding loop body from the stack and
continue with it. There are a few complications in setting up this new
component that we call {\ACommandStore}.

\begin{figure}[tp]
  \begin{align*}
    &
      \begin{array}[t]{|ll|}
        0 &\mapsto \ASession~1
      \end{array}
    &&
      \begin{array}[t]{|ll|}
        0 &\mapsto \ASession~2 \\
        1 &\mapsto \ASession~1
      \end{array}
          &&
             \dots
    &&
       \begin{array}[t]{|ll|}
         0 & \mapsto \ASession~(1+n) \\
         1 & \mapsto \ASession~n \\
           & \vdots \\
         n-1 & \mapsto \ASession~1
       \end{array}
  \end{align*}
  \caption{The session type indices in {\ACommandStore} after 1, 2, and $n$ loop entries}
  \label{fig:commandstore}
\end{figure}
Its type requires some thought.  The top-level type is a
{\ASession~0}. When we enter the first loop, its body refers to a
session of type {\ASession~1}. Hence, the {\ACommandStore} contains
one entry (left column in Figure~\ref{fig:commandstore}).
Entering the next loop pushes a body for the type {\ASession~2}
(middle column). After entering the $n$-th loop, we obtain the
picture on the right of Figure~\ref{fig:commandstore}. Here is a
suitable type definition.
\rstCommandStore

For some $(i : \AFin~(\Asuc~ n))$, the function
$\AgdaFunction{opposite}~i$ returns $n-i$ (as an element of the same
type) and the function {\AtoN} injects an element of the finite number
type into the natural numbers (it is an identity function up to the type). The tricky part is implemented in the
typed push and pop operations on that structure.
\rstPops

The \AgdaFunction{push} function takes a {\ACommandStore} and a
suitable {\ACommand} and returns the store extended by this command
(at position {\Azero}). 
The \AgdaFunction{pop1} function pops the first entry off the
{\ACommandStore}. It gets used in defining the inductive step of the
function \AgdaFunction{pop}, which pops any (legal) number $i$ of entries
from the stack. The definitions are simple but omitted from the text
as they require invoking some technical lemmas about injections (i.e.,
identity functions) from $\AFin~n$ to $\AFin~(\Asuc~n)$.

\rstExecutorSignature\vspace{-1.5\baselineskip}
\rstExecutor

The execution of {\AMU} just pushes the loop body onto the
{\ACommandStore}.
The case for {\ACONTINUE~$i$} jumps to the selected command and pops
all intervening continuations from the store. It also reveals another complication. The recursive
call to {\Aexecutor} happens on a command drawn from the {\ACommandStore}. This
command is unrelated to the current command, which upsets Agda's
termination checker. To console it we introduce a \AgdaFunction{Gas}
argument, which we decrement at each {\ACONTINUE}.

The question is, what to do if we run out of gas?
There are at least three possibilities.
\begin{enumerate}
\item We regard the current formalization as a proof of concept and
  refer the reader to a ``real'' implementation in Haskell, where the
  \AgdaFunction{Gas} argument is not required. We see no
  problem in creating such an implementation, but it would be more
  involved as dependent types are not yet fully integrated in Haskell.
\item We turn the bug into a feature and require that every
  {\ACONTINUE} communicates with the other end of the channel to
  exchange their respective gas levels and quit the loop if one end
  runs out of gas. This choice implies that we would have to a
  continuation argument to  {\ACONTINUE} that acts like a
  finally-clause for exception and finishes the protocol in an orderly
  way.
\item We can modify {\Aexecutor} so that it always takes a single step
  and returns either a continuation and an intermediate state or a
  final result of type $A$. This modification is straightforward in 
  the setting with loops as a value \AgdaFunction{cms} of type {\ACommandStore~$(\Asuc~n)$~$A$}
  can serve as a continuation. To restart a continuation, we simply invoke
  {\Aexecutor} on \AgdaFunction{cms}~\Azero. For concreteness, we show
  the continuation type and an implementation of the restart function.
  \rstAlternativeExecutorRestart
  With this approach, the management of {\Arestart}  has to be
  included in the trusted computing base as it also has to guarantee linear treatment of
  the channel.
\end{enumerate}
The current formalization leaves that question open and just breaks
the protocol. Our preferred solution is a Haskell implementation,
which omits the gas and thus sticks to the protocol.

\section{Going monadic}
\label{sec:going-monadic}
\input{latex/ST-monadic.tex}

We already remarked on the monadic structure apparent in the
callbacks and in the implementation of the {\Aexecutor}
function. Indeed, moving on to a monadic interface makes our session
programs more concise.

We start with a slightly refactored type of commands. More precisely,
we introduce a new {\ACSKIP} command that only performs a state 
transformation via its single callback.
Second, we restate the types of the callbacks for {\ACSEND} and
{\ACRECV} in terms of the state monad.

\mstCommand

Here are the specifics of the types of the callbacks. Each callback
runs in a state monad that handles the application state $A$ on top of
another monad $M$. This construction is expressed in terms of the
monad transformer {\AStateT} applied to the application state
$A$ and the underlying monad $M$. The type of the callback does not give away more
than that.

But wait, using the Agda standard library, we have to state that $M$
has a type that fits a monad and that it implements the
interface {\ARawMonad} (a record that contains the basic monadic
operations).
Fortunately, we can abstract from these issues and adopt a
Haskell-inspired syntax with a straightforward
Agda definition.\footnote{Agda's \AgdaKeyword{syntax} command defines
  a macro that enables abstraction over binders. The newly introduced
  syntax, the definiendum, is \emph{on the right} of the equals
  sign. Putting the record {\ARawMonad~$M$} in double braces enables overloading of the
  monadic operators \cite{DBLP:conf/icfp/DevrieseP11}.}
\mstMonadic

Our running examples become (even more?) concise:
\mstExampleServers
Here, {\Aput}, {\Amodify}, and {\Aget} are monadic functions defined
in the state monad transformer. Their full types are fairly
unreadable, but intuitively we can treat them like this:
\begin{align*}
  \Aput &: A \to ST~A~\top
  & \Amodify &: (A \to A)\to ST~A~A
  & \Aget &: ST~A~A
\end{align*}
{\Aput} overwrites the state with its argument; {\Amodify~$h$} applies 
function $h$ to the state and returns the new state; and {$\Aget = \Amodify~\Aid$} returns the current state.

While we are at it, we also define the {\Aexecutor} function in
monadic style. At this point, the full type of the execution monad
emerges. We already encountered the state transformer on top for
handling the application state. Below we find a reader monad (again
implemented using a monad transformer) that handles access to the
channel. At the bottom, we have the IO monad as before.
\mstExecutor

The most remarkable aspect of this implementation is how unremarkable
it is. However, bear in mind that monads have been used for a long
time to contain linear resources, most notably with the inception of
monadic IO \cite{DBLP:conf/popl/JonesW93}. That is, our proof
obligation of linear handling for the channel becomes even simpler in
this monadic setting.

We conclude this section with the definition of the monadic
acceptor. It essentially invokes the runners of the reader and state
monads and executes the underlying IO action.
\mstAcceptor

\section{Context-free session types}
\label{sec:context-free-session}
\input{latex/ST-contextfree.tex}

Context-free session types
\cite{DBLP:journals/iandc/AlmeidaMTV22,DBLP:journals/toplas/Padovani19,DBLP:conf/icfp/ThiemannV16}
have been conceived to liberate session types from the restriction to
tail recursion. Alleviating this restriction makes session-typed
programming more compositional and enables low-level programming tasks
like the serialization of tree structures.

The basic idea \cite{DBLP:conf/icfp/ThiemannV16} is to reorganize the
type language of session types as follows.
\begin{align*}
  S &::= \Atcfsend{T} \mid \Atcfrecv{T} \mid \Atcfcomp{S}{S} \mid \Atcfskip
\end{align*}
Now $\Atcfsend{T}$ ($\Atcfrecv{T}$) describes just the act of sending
(receiving) a value of type $T$. To combine two session types, we have
to use sequential composition $\Atcfcomp{S}{S}$ with unit
$\Atcfskip$. The branching types and recursion are as before, so we do
not repeat them here.

The Agda encoding of this structure combines straightforwardly with
the accumulated work of the previous sections.
\cstSession

The revised command structure has a few catches that require
explanation.
\cstCmd

The {\ACSKIP} command is associated with a {\Atcfskip} in the session
type. This connection is sometimes needed, but most often it is
undesired. To eliminate superfluous {\Atcfskip}s in the type, we
provide a smart composition constructor that simplifies compositions
with {\Atcfskip}.

The {\ACSEND} and {\ACRECV} commands no longer take a command parameter
to process the continuation session. This functionality is now
provided once and for all by the composition operator.

The composition operator for two commands has an additional argument
to combine the resulting states of the first and second command. Quite
often, with tail-recursive session types, we simply ignore the outcome
of the first command and pass on the second.

The remaining commands, {\ACSELECT} and {\ACCHOICE}, are as before using
the dynamic selection operator for maximum flexibility.

We only show an excerpt of the {\Aexecutor} function.
\cstExec

The implementation of {\ACSKIP} just executes the action.
Composition performs the left command, obtains its final state in
$x_1$, then it performs the right command, obtains its final state in
$x_2$, and updates the returned state to $h~x_1~x_2$.
The implementations for {\AMU} and {\ACONTINUE} are as before in
Section~\ref{sec:going-circles}. The difference is that the
{\ACONTINUE} operation may now appear in the context of a composition
which provides a nontrivial continuation. In
Section~\ref{sec:going-circles}, the function {\Aexecutor} is tail
recursive, but here it is not!


The previously discussed examples can be made to work without much
effort. To expose the difference we concentrate on a protocol that exploits the power of
context-free session types, a server that receives a binary tree.
\cstTreep

The session types {\Aleafp} and {\Abranchp} encode receiving leaf and
a branch of the binary tree type {\AIntTree}. The session type
{\Atreep} provides the enclosing recursion and choice between the leaf
and branch protocols.
The receiver for the leaf wraps the received value in the {\ACLeaf}
constructor and stores it in the application state.
The receiver for the branch obtains the left and right subtrees by
recursive calls {\ACONTINUE~\Azero} and combines the outcomes using
the {\ACBranch} constructor.



\section{Handling multiple channels}
\label{sec:handl-mult-chann}

We have to amend a final element to fully encompass traditional binary
session types: a thread can open and manipulate many channels at a
time. So far, our interfaces were restricted to single channels. We
now turn to lifting this restriction.



\newpage

\section{Discussion}
\label{sec:discussion}


\subsection{Selection and choice with vectors}
\label{sec:select-choice-with}

The reader may wonder why we do not define the constructors for
selection and choice using vectors of length $n$, rather than
functions from $\AFin~n$ (which is isomorphic). Using function extends
straightforwardly to the definition of {\ACommand} where the {\ASession} index of the
continuation command depends on the function argument $i : \AFin~n$.
We would have to define a special vectors type to achieve similar
expressivity. 

\subsection{Code generation}
\label{sec:code-generation}

Instead of interpreting a command value, we could compile it to a
custom library, following the lead of the related work
\cite{DBLP:journals/pacmpl/00020HNY20,DBLP:conf/cc/Miu0Y021}.
We leave such a compiler to future work.

\subsection{Multiparty session types}
\label{sec:mult-sess-types}

We see no issues in extending the approach presented in this work to
protocols with more than two participants. We refrained from doing so
in this work to avoid the extra
complication. Section~\ref{sec:handl-mult-chann} already gives some
insight into the requirements for a multiparty version.

\section{Related work}
\label{sec:related-work}



Several recent implementations of session types rely on Rust, a
language with uniqueness types and ownership, all checked at compile
time. While uniqueness types are quite similar to affine types
(describing values that can be used at most once), they do not quite
get to the level needed for sessions: having an affine session type
for a channel means that an agent can drop the connection anytime
without finishing the protocol, which leads to deadlock at the other
end of the connection. With a proper linear session type, every agent has to
fulfill the protocol up to the closing of the connection.

\cite{DBLP:conf/ecoop/ChenBT22}
\cite{DBLP:conf/ecoop/LagaillardieNY22}
\cite{DBLP:conf/ppopp/CutnerYV22}
\cite{DBLP:conf/coordination/CutnerY21}
\cite{DBLP:conf/coordination/LagaillardieNY20}
\cite{DBLP:journals/corr/abs-1909-05970}
\cite{DBLP:conf/icfp/JespersenML15}


%%
%% The acknowledgments section is defined using the "acks" environment
%% (and NOT an unnumbered section). This ensures the proper
%% identification of the section in the article metadata, and the
%% consistent spelling of the heading.
% \begin{acks}
% To Robert, for the bagels and explaining CMYK and color spaces.
% \end{acks}

%%
%% The next two lines define the bibliography style to be used, and
%% the bibliography file.
\bibliographystyle{ACM-Reference-Format}
\bibliography{references}


%%
%% If your work has an appendix, this is the place to put it.
% \appendix


\end{document}
\endinput
%%
%% End of file `sample-acmsmall-submission.tex'.
